#!/bin/sh

# Tetris game written in pure sh
# 
# I tried to follow the Tetris Guideline(2009). 
# URL: [Tetris Guideline. Tetris Wiki. accessed at 2020-05-23](https://tetris.fandom.com/wiki/Tetris_Guideline)
#
# This script is based on bash-tetris (Author: Kirill Timofeev <kt97679@gmail.com>)
# Thank you!
#
# I implemented
# 
# * Hold Queue
# * Next Queue
# * Random Generation with Bag System
# * Score System
# * Variable Goal System
# * T-Spin / Mini T-Spin
# * Back-to-Back Bonus
# * Extended Placement / Infinite Placement / Classic Lock Down
# * Super / Classic Rotation System
# * Changing the Starting Level 
# 
# not implemented
# 
# * Ghost Piece
# 
# Enjoy :-)
#
# Supported Environments:
#   Linux   sh | o
#   FreeBSD sh | o
#   BusyBox sh | o
#   Solaris sh | x
#
# Github Page:
#   <https://github.com/ContentsViewer/sh-tetris>
# 
# Author:
#   IOE <Github: ContentsViewer>
# 
# Scripting NOTE:
#   * We cannot use `read -s -n 1`
#   * Any process cannot send signals to control(main) process
#     * stty issues error -> cannot read keyboard inputs
#

set -u # non initialized variable is an error

# game versioin
# should follow "Semantic Versioning 2.0.0" <https://semver.org/> 
# so that users have a clear indicator of when an upgrade will introduce breaking changes.
VERSION='2.1.0'

# these signals are used for communicating with each process(i.e. reader, timer, ticker, controller).
# Note:
#   in shell enviroment, should Drop the SIG prefix, just input the signal name.
SIGNAL_TERM=TERM
SIGNAL_LEVEL_UP=USR1
SIGNAL_CANCEL_LOCKDOWN_TIMER=USR1
SIGNAL_RESTART_LOCKDOWN_TIMER=USR2

# Those are commands sent to controller by key press processing code
# In controller they are used as index to retrieve actual function from array
QUIT=0
RIGHT=1
LEFT=2
FALL=3
SOFT_DROP=4
HARD_DROP=5
ROTATE_CW=6
ROTATE_CCW=7
HOLD=8
TOGGLE_BEEP=9
TOGGLE_COLOR=10
TOGGLE_HELP=11
REFRESH_SCREEN=12
LOCKDOWN=13
ACK=14
MY_PID=15

PROCESS_CONTROLLER=0
PROCESS_TICKER=1
PROCESS_TIMER=2
PROCESS_READER=3

BEHAVIOUR_NON=0
BEHAVIOUR_RIGHT=1
BEHAVIOUR_LEFT=2
BEHAVIOUR_ROTATE=3
BEHAVIOUR_FALL=4
BEHAVIOUR_SOFT_DROP=5
BEHAVIOUR_HARD_DROP=6

# The normal Fall Speed is defined here to be the time it takes a Tetrimino to fall by one line. 
# The current level of the game determines the normal Fall Speed using the following equation:
# (0.8 - ((level - 1) * 0.007))^(level-1)
FALL_SPEED_LEVEL_1=1
FALL_SPEED_LEVEL_2=0.793
FALL_SPEED_LEVEL_3=0.618
FALL_SPEED_LEVEL_4=0.473
FALL_SPEED_LEVEL_5=0.355
FALL_SPEED_LEVEL_6=0.262
FALL_SPEED_LEVEL_7=0.190
FALL_SPEED_LEVEL_8=0.135
FALL_SPEED_LEVEL_9=0.094
FALL_SPEED_LEVEL_10=0.064
FALL_SPEED_LEVEL_11=0.043
FALL_SPEED_LEVEL_12=0.028
FALL_SPEED_LEVEL_13=0.018
FALL_SPEED_LEVEL_14=0.011
FALL_SPEED_LEVEL_15=0.007
LEVEL_MAX=15

# color codes
RED=1
GREEN=2
YELLOW=3
BLUE=4
MAGENTA=5
CYAN=6
WHITE=7
ORANGE=208

# Those are Tetrimino type
O_TETRIMINO=0
I_TETRIMINO=1
T_TETRIMINO=2
L_TETRIMINO=3
J_TETRIMINO=4
S_TETRIMINO=5
Z_TETRIMINO=6

# Those are the facing
# Tetrimino has four facings
NORTH=0
EAST=1
SOUTH=2
WEST=3

# Location and size of playfield, color and border
PLAYFIELD_W=10
PLAYFIELD_H=20
PLAYFIELD_X=19
PLAYFIELD_Y=2
BORDER_COLOR=$WHITE

# Location and color of score information
SCORE_X=5
SCORE_Y=7
SCORE_COLOR=$GREEN

ACTION_NONE=0
ACTION_SINGLE=1
ACTION_DOUBLE=2
ACTION_TRIPLE=3
ACTION_TETRIS=4
ACTION_SOFT_DROP=5
ACTION_HARD_DROP=6
ACTION_TSPIN=7
ACTION_TSPIN_SINGLE=8
ACTION_TSPIN_DOUBLE=9
ACTION_TSPIN_TRIPLE=10
ACTION_MINI_TSPIN=11
ACTION_MINI_TSPIN_SINGLE=12

eval SCORE_FACTOR_"$ACTION_NONE"=0
eval SCORE_FACTOR_"$ACTION_SINGLE"=100
eval SCORE_FACTOR_"$ACTION_DOUBLE"=300
eval SCORE_FACTOR_"$ACTION_TRIPLE"=500
eval SCORE_FACTOR_"$ACTION_TETRIS"=800
eval SCORE_FACTOR_"$ACTION_TSPIN"=400
eval SCORE_FACTOR_"$ACTION_TSPIN_SINGLE"=800
eval SCORE_FACTOR_"$ACTION_TSPIN_DOUBLE"=1200
eval SCORE_FACTOR_"$ACTION_TSPIN_TRIPLE"=1600
eval SCORE_FACTOR_"$ACTION_MINI_TSPIN"=100
eval SCORE_FACTOR_"$ACTION_MINI_TSPIN_SINGLE"=200
eval SCORE_FACTOR_"$ACTION_SOFT_DROP"=1
eval SCORE_FACTOR_"$ACTION_HARD_DROP"=2

# A Tetrimino that is Hard Dropped Locks Down immediately. However, if a Tetrimino naturally falls
# or Soft Drops onto a Surface, it is given 0.5 seconds on a Lock Down Timer before it actually
# Locks Down. Three rulesets —Infinite Placement, Extended, and Classic— dictate the conditions
# for Lock Down. The default is Extended Placement.
# 
# Extended Placement Lock Down
#   This is the default Lock Down setting.
#   Once the Tetrimino in play lands on a Surface in the Matrix, the Lock Down Timer starts counting
#   down from 0.5 seconds. Once it hits zero, the Tetrimino Locks Down and the Next Tetrimino’s
#   generation phase starts. The Lock Down Timer resets to 0.5 seconds if the player simply moves
#   or rotates the Tetrimino. In Extended Placement, a Tetrimino gets 15 left/right movements or
#   rotations before it Locks Down, regardless of the time left on the Lock Down Timer. However, if
#   the Tetrimino falls one row below the lowest row yet reached, this counter is reset. In all other
#   cases, it is not reset.
#
# Infinite Placement Lock Down
#   Once the Tetrimino in play lands on a Surface in the Matrix, the Lock Down Timer starts counting
#   down from 0.5 seconds. Once it hits zero, the Tetrimino Locks Down and the Next Tetrimino’s
#   generation phase starts. However, the Lock Down Timer resets to 0.5 seconds if the player simply
#   moves or rotates the Tetrimino. Thus, Infinite Placement allows the player to continue movement
#   and rotation of a Tetrimino as long as there is an actual change in its position or orientation
#   before the timer expires.
#
# Classic Lock Down
#   Classic Lock Down rules apply if Infinite Placement and Extended Placement are turned off.
#   Like Infinite Placement, the Lock Down Timer starts counting down from 0.5 seconds once the
#   Tetrimino in play lands on a Surface. The y-coordinate of the Tetrimino must decrease (i.e., the
#   Tetrimino falls further down in the Matrix) in order for the timer to be reset.
LOCKDOWN_RULE_EXTENDED=0
LOCKDOWN_RULE_INFINITE=1
LOCKDOWN_RULE_CLASSIC=2
LOCKDOWN_ALLOWED_MANIPULATIONS=15

# Location and color of help information
HELP_X=56
HELP_Y=9
HELP_COLOR=$YELLOW

# Next piece location
NEXT_X=42
NEXT_Y=2
NEXT_MAX=7

# Hold piece location
HOLD_X=9
HOLD_Y=2

# Location of 'Game Over!' at end of the game
GAMEOVER_X=$((PLAYFIELD_X + PLAYFIELD_W - 5))  # 1 width equals 2 character
GAMEOVER_Y=$((PLAYFIELD_Y + PLAYFIELD_H / 2))

# Location of 'READY' at start of the game
READY_X=$((PLAYFIELD_X + PLAYFIELD_W))
READY_Y=$((PLAYFIELD_Y + PLAYFIELD_H / 2))

# piece starting location
START_X=3
START_Y=21

# this array holds all possible pieces that can be used in the game
# each piece consists of 4 cells(minos)
# each string is sequence of relative xy coordinates
# Format:
#   piece_<TETRIMINO>_minos_<FACING>='<mino_0_x> <mino_1_y> ...'
#     (0, 0) is top left
#   
#   piece_<TETRIMINO>_rchifts_<FACING>='<POINT_1> <POINT_2> ...'
#     <POINT_<NO>>: <ROTATION_LEFT_shifts> <ROTATION_RIGHT_shifts>
#     <ROTATION_<DIR>_shifts>: <shift_x> <shift_y>

# O-Tetrimino
eval piece_"$O_TETRIMINO"_color=\"$YELLOW\"
eval piece_"$O_TETRIMINO"_minos_"$NORTH"=\'1 0  2 0  1 1  2 1\'
eval piece_"$O_TETRIMINO"_minos_"$EAST"=\' 1 0  2 0  1 1  2 1\'
eval piece_"$O_TETRIMINO"_minos_"$SOUTH"=\'1 0  2 0  1 1  2 1\'
eval piece_"$O_TETRIMINO"_minos_"$WEST"=\' 1 0  2 0  1 1  2 1\'
eval piece_"$O_TETRIMINO"_rshifts_"$NORTH"=\"0  0  0  0   0  0  0  0   0  0  0  0   0  0  0  0   0  0  0  0\"
eval piece_"$O_TETRIMINO"_rshifts_"$EAST"=\" 0  0  0  0   0  0  0  0   0  0  0  0   0  0  0  0   0  0  0  0\"
eval piece_"$O_TETRIMINO"_rshifts_"$SOUTH"=\"0  0  0  0   0  0  0  0   0  0  0  0   0  0  0  0   0  0  0  0\"
eval piece_"$O_TETRIMINO"_rshifts_"$WEST"=\" 0  0  0  0   0  0  0  0   0  0  0  0   0  0  0  0   0  0  0  0\"

# I-Tetrimino
eval piece_"$I_TETRIMINO"_color=\"$CYAN\"
eval piece_"$I_TETRIMINO"_minos_"$NORTH"=\'0 1  1 1  2 1  3 1\'
eval piece_"$I_TETRIMINO"_minos_"$EAST"=\' 2 0  2 1  2 2  2 3\'
eval piece_"$I_TETRIMINO"_minos_"$SOUTH"=\'0 2  1 2  2 2  3 2\'
eval piece_"$I_TETRIMINO"_minos_"$WEST"=\' 1 0  1 1  1 2  1 3\'
eval piece_"$I_TETRIMINO"_rshifts_"$NORTH"=\"0  0  0  0  -1  0 -2  0   2  0  1  0  -1  2 -2 -1   2 -1  1  2\"
eval piece_"$I_TETRIMINO"_rshifts_"$EAST"=\" 0  0  0  0   2  0 -1  0  -1  0  2  0   2  1 -1  2  -1 -2  2 -1\"
eval piece_"$I_TETRIMINO"_rshifts_"$SOUTH"=\"0  0  0  0   1  0  2  0  -2  0 -1  0   1 -2  2  1  -2  1 -1 -2\"
eval piece_"$I_TETRIMINO"_rshifts_"$WEST"=\" 0  0  0  0  -2  0  1  0   1  0 -2  0  -2 -1  1 -2   1  2 -2  1\"

# T-Tetrimino
eval piece_"$T_TETRIMINO"_color=\"$MAGENTA\"
eval piece_"$T_TETRIMINO"_minos_"$NORTH"=\'1 0  0 1  1 1  2 1\'
eval piece_"$T_TETRIMINO"_minos_"$EAST"=\' 1 0  1 1  2 1  1 2\'
eval piece_"$T_TETRIMINO"_minos_"$SOUTH"=\'0 1  1 1  2 1  1 2\'
eval piece_"$T_TETRIMINO"_minos_"$WEST"=\' 1 0  0 1  1 1  1 2\'
eval piece_"$T_TETRIMINO"_rshifts_"$NORTH"=\"0  0  0  0   1  0 -1  0   1  1 -1  1   n  n  n  n   1 -2 -1 -2\"
eval piece_"$T_TETRIMINO"_rshifts_"$EAST"=\" 0  0  0  0   1  0  1  0   1 -1  1 -1   0  2  0  2   1  2  1  2\"
eval piece_"$T_TETRIMINO"_rshifts_"$SOUTH"=\"0  0  0  0  -1  0  1  0   n  n  n  n   0 -2  0 -2  -1 -2  1 -2\"
eval piece_"$T_TETRIMINO"_rshifts_"$WEST"=\" 0  0  0  0  -1  0 -1  0  -1 -1 -1 -1   0  2  0  2  -1  2 -1  2\"

# L-Tetrimino
eval piece_"$L_TETRIMINO"_color=\"$ORANGE\"
eval piece_"$L_TETRIMINO"_minos_"$NORTH"=\'2 0  0 1  1 1  2 1\'
eval piece_"$L_TETRIMINO"_minos_"$EAST"=\' 1 0  1 1  1 2  2 2\'
eval piece_"$L_TETRIMINO"_minos_"$SOUTH"=\'0 1  1 1  2 1  0 2\'
eval piece_"$L_TETRIMINO"_minos_"$WEST"=\' 0 0  1 0  1 1  1 2\'
eval piece_"$L_TETRIMINO"_rshifts_"$NORTH"=\"0  0  0  0   1  0 -1  0   1  1 -1  1   0 -2  0 -2   1 -2 -1 -2\"
eval piece_"$L_TETRIMINO"_rshifts_"$EAST"=\" 0  0  0  0   1  0  1  0   1 -1  1 -1   0  2  0  2   1  2  1  2\"
eval piece_"$L_TETRIMINO"_rshifts_"$SOUTH"=\"0  0  0  0  -1  0  1  0  -1  1  1  1   0 -2  0 -2  -1 -2  1 -2\"
eval piece_"$L_TETRIMINO"_rshifts_"$WEST"=\" 0  0  0  0  -1  0 -1  0  -1 -1 -1 -1   0  2  0  2  -1  2 -1  2\"

# J-Tetrimino
eval piece_"$J_TETRIMINO"_color=\"$BLUE\"
eval piece_"$J_TETRIMINO"_minos_"$NORTH"=\'0 0  0 1  1 1  2 1\'
eval piece_"$J_TETRIMINO"_minos_"$EAST"=\' 1 0  2 0  1 1  1 2\'
eval piece_"$J_TETRIMINO"_minos_"$SOUTH"=\'0 1  1 1  2 1  2 2\'
eval piece_"$J_TETRIMINO"_minos_"$WEST"=\' 1 0  1 1  0 2  1 2\'
eval piece_"$J_TETRIMINO"_rshifts_"$NORTH"=\"0  0  0  0   1  0 -1  0   1  1 -1  1   0 -2  0 -2   1 -2 -1 -2\"
eval piece_"$J_TETRIMINO"_rshifts_"$EAST"=\" 0  0  0  0   1  0  1  0   1 -1  1 -1   0  2  0  2   1  2  1  2\"
eval piece_"$J_TETRIMINO"_rshifts_"$SOUTH"=\"0  0  0  0  -1  0  1  0  -1  1  1  1   0 -2  0 -2  -1 -2  1 -2\"
eval piece_"$J_TETRIMINO"_rshifts_"$WEST"=\" 0  0  0  0  -1  0 -1  0  -1 -1 -1 -1   0  2  0  2  -1  2 -1  2\"

# S-Tetrimino
eval piece_"$S_TETRIMINO"_color=\"$GREEN\"
eval piece_"$S_TETRIMINO"_minos_"$NORTH"=\'1 0  2 0  0 1  1 1\'
eval piece_"$S_TETRIMINO"_minos_"$EAST"=\' 1 0  1 1  2 1  2 2\'
eval piece_"$S_TETRIMINO"_minos_"$SOUTH"=\'1 1  2 1  0 2  1 2\'
eval piece_"$S_TETRIMINO"_minos_"$WEST"=\' 0 0  0 1  1 1  1 2\'
eval piece_"$S_TETRIMINO"_rshifts_"$NORTH"=\"0  0  0  0   1  0 -1  0   1  1 -1  1   0 -2  0 -2   1 -2 -1 -2\"
eval piece_"$S_TETRIMINO"_rshifts_"$EAST"=\" 0  0  0  0   1  0  1  0   1 -1  1 -1   0  2  0  2   1  2  1  2\"
eval piece_"$S_TETRIMINO"_rshifts_"$SOUTH"=\"0  0  0  0  -1  0  1  0  -1  1  1  1   0 -2  0 -2  -1 -2  1 -2\"
eval piece_"$S_TETRIMINO"_rshifts_"$WEST"=\" 0  0  0  0  -1  0 -1  0  -1 -1 -1 -1   0  2  0  2  -1  2 -1  2\"

# Z-Tetrimino
eval piece_"$Z_TETRIMINO"_color=\"$RED\"
eval piece_"$Z_TETRIMINO"_minos_"$NORTH"=\"0 0  1 0  1 1  2 1\"
eval piece_"$Z_TETRIMINO"_minos_"$EAST"=\" 2 0  1 1  2 1  1 2\"
eval piece_"$Z_TETRIMINO"_minos_"$SOUTH"=\"0 1  1 1  1 2  2 2\"
eval piece_"$Z_TETRIMINO"_minos_"$WEST"=\" 1 0  0 1  1 1  0 2\"
eval piece_"$Z_TETRIMINO"_rshifts_"$NORTH"=\"0  0  0  0   1  0 -1  0   1  1 -1  1   0 -2  0 -2   1 -2 -1 -2\"
eval piece_"$Z_TETRIMINO"_rshifts_"$EAST"=\" 0  0  0  0   1  0  1  0   1 -1  1 -1   0  2  0  2   1  2  1  2\"
eval piece_"$Z_TETRIMINO"_rshifts_"$SOUTH"=\"0  0  0  0  -1  0  1  0  -1  1  1  1   0 -2  0 -2  -1 -2  1 -2\"
eval piece_"$Z_TETRIMINO"_rshifts_"$WEST"=\" 0  0  0  0  -1  0 -1  0  -1 -1 -1 -1   0  2  0  2  -1  2 -1  2\"

eval T_TETRIMINO_"$NORTH"_SIDES=\"0 0  2 0  0 2  2 2\"
eval T_TETRIMINO_"$EAST"_SIDES=\" 2 0  0 2  0 0  0 2\"
eval T_TETRIMINO_"$SOUTH"_SIDES=\"2 2  0 2  2 0  0 0\"
eval T_TETRIMINO_"$WEST"_SIDES=\" 0 2  0 0  2 2  2 0\"

help='
←         Move Left or Right
→         Move Right
↑, x      Rotate Clockwise
z         Rotate Counter-Clockwise
c         Hold
↓         Soft Drop
Space     Hard Drop
R         Refresh Screen
C         Toggle Color
B         Toggle Beep
H         Toggle Help
Q, ESCx2  Quit
'

usage="
Usage: ${0##*/} [options]

Options:
 -d, --debug          debug mode
 -l, --level <LEVEL>  game level (default=1). range from 1 to $LEVEL_MAX
 --rotation <MODE>    use 'Super' or 'Classic' rotation system
                      MODE can be 'super'(default) or 'classic'
 --lockdown <RULE>    Three rulesets —Infinite Placement, Extended, and Classic— 
                      dictate the conditions for Lock Down.
                      RULE can be 'extended'(default), 'infinite', 'classic'
 --no-color           don't display colors
 --no-beep            disable beep
 --hide-help          don't show help on start

 -h, --help     display this help and exit
 -V, --version  output version infromation and exit

Version:
 $VERSION
"

# the queue of the next tetriminos to be placed.
# the reference says the next six tetrimonos should be shown.
next_queue=''

# the hold queue allows the player to hold a falling tetrimino for as long as they wish.
hold_queue=''

# Tetris uses a “bag” system to determine the sequence of Tetriminos that appear during game
# play. This system allows for equal distribution among the seven Tetriminos.
# 
# The seven different Tetriminos are placed into a virtual bag, then shuffled into a random order.
# This order is the sequence that the bag “feeds” the Next Queue. Every time a new Tetrimino is
# generated and starts its fall within the Matrix, the Tetrimino at the front of the line in the bag is
# placed at the end of the Next Queue, pushing all Tetriminos in the Next Queue forward by one.
# The bag is refilled and reshuffled once it is empty.
bag=''

# the Variable Goal System requires that the player clears 5 lines at level 1, 10 lines at
# level 2, 15 at level 3 and so on, adding an additional five lines to the Goal each level through 15.
# with the Variable Goal System of adding 5 lines per level, the player is required to clear 600 lines
# by level 15. 
# 
# This system also includes line bonuses to help speed up the game.
# To speed up the process of “clearing” 600 lines, in the Variable Goal System the number of Line
# Clears awarded for any action is directly based off the score of the action performed (score
# at level 1 / 100 = Total Line Clears
goal=5

# There is a special bonus for Back-to-Backs, which is when two actions
# such as a Tetris and T-Spin Double take place without a Single, Double, or Triple Line Clear 
# occurring between them. 
# 
# Back-to-Back Bonus
#   Bonus for Tetrises, T-Spin Line Clears, and Mini T-Spin Line Clears
#   performed consecutively in a B2B sequence.
b2b_sequence_continues=false

lockdown_rule=$LOCKDOWN_RULE_EXTENDED

score=0                    # score variable initialization
level=1                    # level variable initialization
lines_completed=0          # completed lines counter initialization
already_hold=false         #
help_on=true               # if this flag is true help is shown, if false, hide
beep_on=true               #
no_color=false             # do we use color or not
showtime=true              # controller runs while this flag is true
discard_cmds_timepoint=0   # cmds issued before this time is discarded
empty_cell=' .'            # how we draw empty cell
filled_cell='[]'           # how we draw filled cell
lands_on=false             #
manipulation_counter=0     #
lowest_line=$START_X       #
current_tspin=$ACTION_NONE #


# screen_buffer is variable, that accumulates all screen changes
# this variable is printed in controller once per game cycle
screen_buffer=''
puts() {
  screen_buffer="$screen_buffer""$1"
}

flush_screen() {
  printf "$screen_buffer"
  screen_buffer=''
}

# move cursor to (x,y) and print string
# (1,1) is upper left corner of the screen
xyprint() {
  puts "\033[${2};${1}H${3}"
}

show_cursor() {
  printf "\033[?25h"
}

hide_cursor() {
  printf "\033[?25l"
}

# foreground color
set_fg() {
  $no_color && return
  puts "\033[38;5;${1}m"
  # puts "\033[3${1}m" # for using 8/16 Colors
}

# background color
set_bg() {
  $no_color && return
  puts "\033[48;5;${1}m"
  # puts "\033[4${1}m" # for using 8/16 Colors
}

reset_colors() {
  puts "\033[0m"
}

set_bold() {
  puts "\033[1m"
}

beep() {
  $beep_on || return
  printf '\007'
}

now() {
  echo $(date +%s)
}

# Get pid of current process regardless of subshell
# 
# $$: 
#   Expands to the process ID of the shell. 
#   In a () subshell, it expands to the process ID of the current shell, not the subshell.
# 
# Notice that some shells (eg. zsh or ksh93) do NOT start a subprocess 
# for each subshell created with (...); in that case, $pid may be end up 
# being the same as $$, which is just right, because that's the PID of 
# the process getpid was called from.
# 
# ref: <https://unix.stackexchange.com/questions/484442/how-can-i-get-the-pid-of-a-subshell>
# 
# usage getpid [varname]
get_pid(){
  pid=$(exec sh -c 'echo "$PPID"')
  test "$1" && eval "$1=\$pid"
}

send_signal() {
  kill -$1 $2
}

discard_cmds() {
  discard_cmds_timepoint=$(now)
}

rand() {
  LF=$(printf '\\\n_');LF=${LF%_}       # define LF for sed.
  (ps -Ao pid,etime,pcpu,vsz; date)   | # the source of randamize(process info + date)
  od -t d4 -A n -v                    | # Quantified(-A n: hide address on left side.; -v: disable Omission)
  sed 's/[^0-9]\{1,\}/'"$LF"'/g'      | # replace strings starting with no number with LF.
  grep '[0-9]'                        | # get only numbers
  tail -n 42                          | # get tail 42 before eof
  sed 's/.*\(.\{8\}\)$/\1/g'          | # the number less than 100000000(2^32)
  awk 'BEGIN{a=-2147483648;}
      {a+=$1;}
      END{srand(a); print rand();}'
}

level_up() {
  level=$((level + 1))                     # increment level
  goal=$((goal + level * 5))               # adding an additional five lines to the Goal
  send_signal $SIGNAL_LEVEL_UP $ticker_pid # and send level-up signal to all instances of this script (please see ticker for more details)
}

fill_bag() {
  bag=$(
    echo \
"$(rand) $O_TETRIMINO
$(rand) $I_TETRIMINO
$(rand) $T_TETRIMINO
$(rand) $L_TETRIMINO
$(rand) $J_TETRIMINO
$(rand) $S_TETRIMINO
$(rand) $Z_TETRIMINO" |
    sort -k1 | 
    cut -d' ' -f2 | 
    (
      while read piece; do
        printf "$piece"' '
      done
    )
  )
}

#  the Tetrimino at the front of the line in the bag is placed at the end of the Next Queue
feed_next_queue() {
  local poped

  [ -z "$bag" ] && fill_bag       # if bag is empty, then fill the bag.
  set $bag
  poped="$1"; shift; bag="$*"     # pop the tetrimino
  next_queue="$next_queue $poped" # place tetrimino at the end of the Next Queue
}

get_next() {
  local next_piece

  set $next_queue
  next_piece="$1"; # peek the next piece

  # next piece becomes current
  # place current at the top of play field.
  generate_tetrimino "$next_piece"
  
  # check if piece can be placed at this location, if not - game over
  new_piece_location_ok $current_piece_x $current_piece_y || quit
  show_current

  # now let's shift next queue
  clear_next
  shift; next_queue="$*" # pop the next piece from the front of queue
  feed_next_queue        # push tetrimino into queue; keep queue size
  show_next
}

hold_tetrimino() {
  #  Between Holds, A Lock Down must take place. reset this flag in move_piece().
  "$already_hold" && return
  already_hold=true

  # if hold queue is empty,
  [ -z "$hold_queue" ] && {
    hold_queue="$current_piece" # hold current tetrimino
    clear_current
    get_next                    # the Next Tetrimino is generated from the Next Queue and begins to fall
    show_hold
    return
  }
  clear_current
  clear_hold

  # swap piece
  held_piece="$hold_queue"
  hold_queue="$current_piece"

  generate_tetrimino "$held_piece"
  show_hold
}

# generate tetrimino in play field
generate_tetrimino() {
  # Arguments:
  #   1 - tetrimino to generate
  current_piece="$1"

  # beginning from its generation position and North Facing orientation.
  update_location $START_X $START_Y
  current_piece_rotation="$NORTH"

  current_piece_behaviour=$BEHAVIOUR_NON

  lowest_line=$START_Y
  lands_on=false
}

what_type_tspin() {
  local pos_x=$1 pos_y=$2 rotation=$3 side_x side_y side

  shift $#
  eval set \$T_TETRIMINO_"$rotation"_SIDES
  side=0 # 1: A; 2: B; 3: C; 4: D
  while [ $# -gt 0 ]; do
    side=$((side + 1))
    side_x=$1; side_y=$2
    side_x=$((pos_x + side_x)); side_y=$((pos_y - side_y))

    [ $side_x -lt 0 ]            || 
    [ $side_x -ge $PLAYFIELD_W ] ||
    [ $side_y -lt 0 ]            && {
      # touching wall
      eval is_touched_${side}=true
      shift 2; continue
    }

    field_cell=$(eval echo \"\$playfield_"$side_y"_"$side_x"\")
    [ $field_cell -ne -1 ]       && 
    eval is_touched_${side}=true || eval is_touched_${side}=false

    shift 2
  done

  # if Sides A and B + (C or D) are touching a Surface
  # considered a T-Spin
  $is_touched_3 || $is_touched_4 && $is_touched_1 && $is_touched_2 && {
    echo $ACTION_TSPIN
    return
  }

  # if Sides C and D + (A or B) are touching a Surface
  # considered a Mini T-Spin
  $is_touched_1 || $is_touched_2 && $is_touched_3 && $is_touched_4 && {
    echo $ACTION_MINI_TSPIN
    return
  }

  echo $ACTION_NONE
  return
}

new_piece_location_ok() {
  # Arguments: 1 - new x coordinate of the piece, 2 - new y coordinate of the piece
  # test if piece can be moved to new location

  local x_test y_test x y lx ly field_cell

  x_test="$1"; y_test="$2" # at first, we should preserve the parameters ...
  shift $#                 # .. and we shift all.

  # set minos coordinates into parameters
  # $1 - x, $2 - y
  eval set \$piece_"$current_piece"_minos_"$current_piece_rotation"
  
  # loop through tetrimino minos: 4 minos, each has 2 coordinates
  while [ $# -gt 0 ]; do
    lx="$1"; ly="$2"
    x=$((x_test + lx)) # new x coordinate of piece cell
    y=$((y_test - ly)) # new y coordinate of piece cell

    [ "$y" -lt 0 ]              || 
    [ "$x" -lt 0 ]              || 
    [ "$x" -ge "$PLAYFIELD_W" ] && return 1 # false; check if we are out of the play field

    field_cell=$(eval echo \"\$playfield_"$y"_"$x"\")
    [ "$field_cell" != -1 ] && return 1    # false; check if location is already occupied
  
    shift 2 # shift to next minos coordinates
  done
  return 0
}

# this function updated occupied cells in playfield array after piece is dropped
flatten_playfield() {
  local color lx ly x y

  eval color=\"\$piece_"$current_piece"_color\"

  # set minos coordinates into parameters
  # $1 - x, $2 - y
  eval set \$piece_"$current_piece"_minos_"$current_piece_rotation"
  
  # loop through tetrimino minos: 4 minos, each has 2 coordinates
  while [ $# -gt 0 ]; do
    lx="$1"; ly="$2"
    x=$((current_piece_x + lx))
    y=$((current_piece_y - ly))
    eval playfield_"$y"_"$x"="$color"
    shift 2 # shift to next minos coordinates
  done
}

is_line_completed() {
  # Arguments: 1 - line y of playfield you want to check
  # check the line is completed
  local x line_y="$1"

  x=$((PLAYFIELD_W - 1))
  while [ "$x" -ge 0 ]; do
    field_cell=$(eval echo \"\$playfield_"$line_y"_"$x"\")
    [ "$field_cell" -eq -1 ] && return 1 # false. empty cell found
    x=$((x - 1))
  done;

  return 0 # true
}

# this function goes through playfield array and eliminates lines without empty cells
process_complete_lines() {
  local x y yi completed_lines field_cell completed_lines_count action

  completed_lines=''
  y=0
  while [ "$y" -lt "$PLAYFIELD_H" ]; do
    is_line_completed "$y" && completed_lines="$completed_lines $y"
    y=$((y + 1))
  done

  [ -z "$completed_lines" ] && return "$ACTION_NONE"
  set $completed_lines
  completed_lines_count=$#

  # move lines down. move cells from y to yi
  y=-1; yi=0
  while [ "$y" -lt "$START_Y" ]; do
    y=$((y + 1))
    [ $# -gt 0 ]      &&
    [ "$1" -eq "$y" ] && {
      shift
      continue
    }
    [ "$y" -eq "$yi" ] && { # dont need to swap if y equals yi.
      yi=$((yi + 1))
      continue
    }

    x=$((PLAYFIELD_W - 1))
    while [ "$x" -ge 0 ]; do
      field_cell=$(eval echo \"\$playfield_"$y"_"$x"\")
      eval playfield_"$yi"_"$x"=\"$field_cell\"
      x=$((x - 1))
    done
    yi=$((yi + 1))
  done

  # now let's mark lines from line yi to top line of the playfield as free.
  while [ "$yi" -le "$START_Y" ]; do
    x=$((PLAYFIELD_W - 1))
    while [ "$x" -ge 0 ]; do
      eval playfield_"$yi"_"$x"=-1
      x=$((x - 1))
    done
    yi=$((yi + 1))
  done

  action="$ACTION_NONE"
  case "$completed_lines_count" in
    1) action="$ACTION_SINGLE" ;;
    2) action="$ACTION_DOUBLE" ;;
    3) action="$ACTION_TRIPLE" ;;
    4) action="$ACTION_TETRIS" ;;
  esac
  return "$action"
}

process_fallen_piece() {
  flatten_playfield
  process_complete_lines; action="$?"
  [ $current_piece -eq $T_TETRIMINO ]                &&
  [ $current_piece_behaviour -eq $BEHAVIOUR_ROTATE ] && {
    case $current_tspin in
      $ACTION_TSPIN)
        case $action in
          $ACTION_SINGLE) action=$ACTION_TSPIN_SINGLE ;;
          $ACTION_DOUBLE) action=$ACTION_TSPIN_DOUBLE ;;
          $ACTION_TRIPLE) action=$ACTION_TSPIN_TRIPLE ;;
          $ACTION_NONE)   action=$ACTION_TSPIN        ;;
          *)              echo "T: $action" >> .log   ;; # For Debugging. cannot be reached
        esac
        ;;
      $ACTION_MINI_TSPIN)
        case $action in
          $ACTION_SINGLE) action=$ACTION_MINI_TSPIN_SINGLE ;;
          $ACTION_NONE)   action=$ACTION_MINI_TSPIN        ;;
          *)              echo "T: $action" >> .log        ;; # For Debugging. cannot be reached
        esac
        ;;
    esac
  }
  update_score "$action"

  [ "$action" -eq $ACTION_NONE ]       ||
  [ "$action" -eq $ACTION_MINI_TSPIN ] ||
  [ "$action" -eq $ACTION_TSPIN ]      && return

  beep
  redraw_playfield
  discard_cmds
}

update_score() {
  # Arguments: 1 - ACTION name. ex: ACTION_SINGLE
  local factor score_to_add lines_to_add actions_to_show i

  eval factor=\"\$SCORE_FACTOR_"$1"\"

  score_to_add=0
  lines_to_add=0
  actions_to_show=''

  # A Back-to-Back sequence is only broken by a Single, Double, or Triple Line Clear.
  # Locking down a Tetrimino without clearing a line or holding a Tetrimino does not
  # break the Back-to-Back sequence.
  case "$1" in
    "$ACTION_SINGLE")
      score_to_add=$((level * factor)) # Awarded Line Clears
      lines_to_add=$((factor / 100))
      b2b_sequence_continues=false
      actions_to_show='Single'
      ;;
    "$ACTION_DOUBLE")
      score_to_add=$((level * factor)) # Awarded Line Clears
      lines_to_add=$((factor / 100))
      b2b_sequence_continues=false
      actions_to_show='Double'
      ;;
    "$ACTION_TRIPLE")
      score_to_add=$((level * factor)) # Awarded Line Clears
      lines_to_add=$((factor / 100))
      b2b_sequence_continues=false
      actions_to_show='Triple'
      ;;
    "$ACTION_TETRIS")
      score_to_add=$((level * factor)) # Awarded Line Clears
      lines_to_add=$((factor / 100))
      actions_to_show='Tetris'
      ;;
    "$ACTION_MINI_TSPIN")
      score_to_add=$((level * factor)) # Awarded Line Clears
      lines_to_add=$((factor / 100))
      actions_to_show='Mini T-Spin'
      ;;
    "$ACTION_MINI_TSPIN_SINGLE")
      score_to_add=$((level * factor)) # Awarded Line Clears
      lines_to_add=$((factor / 100))
      actions_to_show='Mini T-Spin:Single'
      ;;
    "$ACTION_TSPIN")
      score_to_add=$((level * factor)) # Awarded Line Clears
      lines_to_add=$((factor / 100))
      actions_to_show='T-Spin'
      ;;
    "$ACTION_TSPIN_SINGLE")
      score_to_add=$((level * factor)) # Awarded Line Clears
      lines_to_add=$((factor / 100))
      actions_to_show='T-Spin:Single'
      ;;
    "$ACTION_TSPIN_DOUBLE")
      score_to_add=$((level * factor)) # Awarded Line Clears
      lines_to_add=$((factor / 100))
      actions_to_show='T-Spin:Double'
      ;;
    "$ACTION_TSPIN_TRIPLE")
      score_to_add=$((level * factor)) # Awarded Line Clears
      lines_to_add=$((factor / 100))
      actions_to_show='T-Spin:Triple'
      ;;
    "$ACTION_SOFT_DROP")
      score_to_add=$factor
      ;;
    "$ACTION_HARD_DROP")
      score_to_add=$factor
      ;;
  esac

  # Awarded Back-to-Back Bonus
  # start a Back-to-Back sequence after Awarded b2b bonus
  # The first Line Clear in the Back-to-Back sequence does not receive the Back-to-Back
  # Bonus. Only consecutive qualifying Back-to-Back Line Clears after the first in the sequence
  # receive the Back-to-Back Bonus.
  case $1 in
    "$ACTION_TETRIS"|\
    "$ACTION_TSPIN_SINGLE"|"$ACTION_TSPIN_DOUBLE"|"$ACTION_TSPIN_TRIPLE"|\
    "$ACTION_MINI_TSPIN_SINGLE")
      $b2b_sequence_continues && {
        score_to_add=$((score_to_add + score_to_add / 2))
        lines_to_add=$((lines_to_add + lines_to_add / 2))
        actions_to_show="$actions_to_show:B2B"
      }
      b2b_sequence_continues=true;;
  esac

  score=$((score + score_to_add))
  lines_completed=$((lines_completed + lines_to_add))

  [ "$level" -le "$LEVEL_MAX" ]      &&
  [ "$lines_completed" -ge "$goal" ] && {
    level_up
  }

  set_bold
  set_fg "$SCORE_COLOR"
  xyprint "$SCORE_X" "$SCORE_Y"       "│SCORE: "
  xyprint "$SCORE_X" $((SCORE_Y + 1)) "│$score"
  xyprint "$SCORE_X" $((SCORE_Y + 2)) "│"
  xyprint "$SCORE_X" $((SCORE_Y + 3)) "│LINES   $lines_completed"
  xyprint "$SCORE_X" $((SCORE_Y + 4)) "│LEVEL   $level"
  xyprint "$SCORE_X" $((SCORE_Y + 5)) "│GOAL    $goal"
  
  [ -z "$actions_to_show" ] || {
    IFS_SAVE=$IFS; IFS=:
    shift $#; set $actions_to_show
    IFS=$IFS_SAVE

    xyprint "$SCORE_X" $((SCORE_Y + 7)) "             " # clear 3 rows
    xyprint "$SCORE_X" $((SCORE_Y + 8)) "             " #
    xyprint "$SCORE_X" $((SCORE_Y + 9)) "             " #
    i=7
    while [ $# -gt 0 ]; do
      xyprint "$SCORE_X" $((SCORE_Y + i)) "$1"
      i=$((i + 1)); shift
    done
  }

  reset_colors
}

update_location() {
  current_piece_x="$1"
  current_piece_y="$2"
  [ $current_piece_y -lt $lowest_line ] && {
    lowest_line=$current_piece_y
    on_reach_lowest
  }
}

on_reach_lowest() {
  # echo 'LOW' >> .log # For Debugging
  manipulation_counter=0

  # if the tetrimino reached the lowest, it means that tetrimino has space to fall
  # and not lifts up before it lands on.
  # so, we can cancel lockdown timer which is running.
  send_signal "$SIGNAL_CANCEL_LOCKDOWN_TIMER" $timer_pid
}

# this function called when player manipulate tetrimino.
on_manipulation() {
  case $lockdown_rule in
    $LOCKDOWN_RULE_INFINITE)
      send_signal "$SIGNAL_RESTART_LOCKDOWN_TIMER" $timer_pid
      ;;
    $LOCKDOWN_RULE_EXTENDED)
      [ $manipulation_counter -lt $LOCKDOWN_ALLOWED_MANIPULATIONS ] && {
        send_signal "$SIGNAL_RESTART_LOCKDOWN_TIMER" $timer_pid
        manipulation_counter=$((manipulation_counter + 1))
        # echo "mc $manipulation_counter" >> .log # For Debugging. to check counter
      }
      ;;
  esac
}

can_maniqulate() {
  case $lockdown_rule in
    $LOCKDOWN_RULE_EXTENDED)
      [ $manipulation_counter -ge $LOCKDOWN_ALLOWED_MANIPULATIONS ] && {
        return 1 # false
      }
      ;;
  esac
  return 0
}

move_piece() {
  # arguments: 1 - new x coordinate, 2 - new y coordinate
  # moves the piece to the new location if possible
  immediately_lockdown=${3:-false}

  if new_piece_location_ok "$1" "$2"; then            # if new location is ok
    [ "$2" -lt "$current_piece_y" ] && lands_on=false # can move down means not lands on
    clear_current                                     # let's wipe out piece current location
    update_location $1 $2                             # update location
    show_current                                      # and draw piece in new location
    return 0                                          # nothing more to do here
  fi                                                  # if we could not move piece to new location

  [ "$2" -eq "$current_piece_y" ] && return 1         # and this was horizontal move
  
  if "$immediately_lockdown"; then
    lockdown
  else
    "$lands_on" || {
      # echo 'Send Lock' >> .log # for debugging to check when signal fired.
      send_signal "$SIGNAL_RESTART_LOCKDOWN_TIMER" $timer_pid
    }
  fi
  lands_on=true

  return 1
}

lockdown() {
  # if can fall, dont lock down
  new_piece_location_ok "$current_piece_x" $((current_piece_y - 1)) && return
  
  process_fallen_piece # let's finalize this piece
  get_next             # and start the new one
  already_hold=false   # player can hold the falling tetrimino.
}

rotate_piece_classic() {
  # arguments: 1 - rotation direction; 1: clockwise; -1: counter-clockwise
  local direction="$1" old_rotation new_rotation
  
  old_rotation=$current_piece_rotation                             # preserve current orientation
  new_rotation=$((old_rotation + direction + 4))
  new_rotation=$((new_rotation % 4))                               # calculate new orientation
  current_piece_rotation=$new_rotation                             # set orientation to new
  if new_piece_location_ok $current_piece_x $current_piece_y; then # check if new orientation is ok
    [ $current_piece -eq $T_TETRIMINO ] && {
      current_tspin=$(what_type_tspin $current_piece_x $current_piece_y $new_rotation)
    }
    current_piece_rotation=$old_rotation                           # if yes - restore old rotation ...
    clear_current                                                  # ... clear piece image 
    current_piece_rotation=$new_rotation                           # ... set new orientation
    show_current                                                   # ... draw piece with new orientation
    return 0
  fi
  # if new orientation is not ok
  current_piece_rotation=$old_rotation # restore old orientation
  return 1
}

rotate_piece_super() {
  # arguments: 1 - rotation direction. 1: clockwise; -1: counter-clockwise
  local direction="$1" old_rotation new_rotation shift_x shift_y new_x new_y point
  
  old_rotation=$current_piece_rotation # preserve current orientation

  new_rotation=$((old_rotation + direction + 4)) #
  new_rotation=$((new_rotation % 4))             # calculate new orientation

  current_piece_rotation=$new_rotation

  # test each rotation point. Each Tetrimino has five possible rotation points. 
  shift $#
  eval set \$piece_${current_piece}_rshifts_${old_rotation}
  # now parameters setted like below
  # '<POINT1> <POINT2> <POINT3> <POINT4> <POINT5>'
  #   <POINT<NO>>: '<LEFT_SHIFT_X> <LEFT_SHIFT_Y> <RIGHT_SHIFT_X> <RIGHT_SHIFT_Y>'
  [ $direction -eq 1 ] && shift 2 # if rotate clockwise(RIGHT) shift 2 to next xy-coordinates of RIGHT
  while [ $# -gt 0 ]; do
    [ $1 = 'n' ] && {        # if 'not used' appears, skip this point
      [ $# -lt 4 ] && break;
      shift 4; continue; 
    }

    shift_x=$1; shift_y=$2
    new_x=$((current_piece_x + shift_x))
    new_y=$((current_piece_y + shift_y))
    if new_piece_location_ok $new_x $new_y; then # check if new orientation is ok
      [ $current_piece -eq $T_TETRIMINO ] && {
        # echo $# >> .log # For Debugging. to check parameter position
        current_tspin=$(what_type_tspin $new_x $new_y $new_rotation)
      }
      current_piece_rotation=$old_rotation       # if yes - restore old rotation ...
      clear_current                              # ... clear piece image
      current_piece_rotation=$new_rotation       # ... set new orientation
      update_location $new_x $new_y              # ... set new location
      show_current                               # ... draw piece with new pose
      return 0                                   # nothing to do more here
    fi
    
    [ $# -lt 4 ] && break;
    shift 4 # test next rotation point
  done

  # if new orientation is not ok
  current_piece_rotation=$old_rotation # restore old orientation
  return 1
}

move_right() {
  can_maniqulate || return
  move_piece $((current_piece_x + 1)) "$current_piece_y" && {
    # if successfuly move
    current_piece_behaviour=$BEHAVIOUR_RIGHT
    on_manipulation
  }
}

move_left() {
  can_maniqulate || return
  move_piece $((current_piece_x - 1)) "$current_piece_y" && {
    # if successfuly move
    current_piece_behaviour=$BEHAVIOUR_LEFT
    on_manipulation
  } 
}

rotate_cw() {
  can_maniqulate || return
  $rotate_piece_func 1 && {
    # if successfuly rotate
    current_piece_behaviour=$BEHAVIOUR_ROTATE
    on_manipulation
  }
}

rotate_ccw() {
  can_maniqulate || return
  $rotate_piece_func -1 && {
    # if successfuly rotate
    current_piece_behaviour=$BEHAVIOUR_ROTATE
    on_manipulation
  }
}

fall() {
  move_piece "$current_piece_x" $((current_piece_y - 1)) && {
    # if successfuly move
    current_piece_behaviour=$BEHAVIOUR_FALL
  }
}

soft_drop() {
  move_piece "$current_piece_x" $((current_piece_y - 1)) && {
    # if successfuly move
    current_piece_behaviour=$BEHAVIOUR_SOFT_DROP
    update_score "$ACTION_SOFT_DROP"
  }
}

hard_drop() {
  # move piece all way down
  while move_piece $current_piece_x $((current_piece_y - 1)) true; do
    # if successfuly move
    update_score "$ACTION_HARD_DROP"
  done
  
  current_piece_behaviour=$BEHAVIOUR_HARD_DROP
}

hold() {
  hold_tetrimino
}

# playfield is 2-dimensional array, data is stored as follows:
# a_{y,x}
#   x - 0, ..., (PLAYFIELD_W-1)
#   y - 0, ..., (PLAYFIELD_H-1), ..., (START_Y-1)
# each array element contains cell color value or -1 if cell is empty
redraw_playfield() {
  local x y yp field_cell

  y=0
  while [ "$y" -lt "$PLAYFIELD_H" ]; do
    yp=$((PLAYFIELD_Y + PLAYFIELD_H - y - 1))
    xyprint $PLAYFIELD_X $yp '' # put the cursor on the front of line
    x=0
    while [ "$x" -lt "$PLAYFIELD_W" ]; do
      field_cell=$(eval echo \"\$playfield_"$y"_"$x"\")
      
      if [ "$field_cell" -eq -1 ]; then
        puts "$empty_cell"
      else
        set_fg "$field_cell"
        set_bg "$field_cell"
        puts "$filled_cell"
        reset_colors
      fi
      x=$((x + 1))
    done
    y=$((y + 1))
  done
}

draw_piece() {
  # Arguments:
  #   1 - x, 2 - y, 3 - type, 4 - rotation, 5 - cell content, 6 - mask with playfield
  local posx posy type rotation content lx ly x y mask

  # at first, we should save arguments.
  posx="$1"; posy="$2"; type="$3"; rotation="$4"; content="$5"; mask="${6:-false}"
  shift $#

  # set minos coordinates.
  eval set \$piece_"$type"_minos_"$rotation"

  # loop through tetrimino minos: 4 minos, each has 2 coordinates
  while [ $# -gt 0 ]; do
    # relative coordinates are retrieved bassed on orientation and added to absolute coordinates
    lx=$1; ly=$2
    x=$((posx + lx * 2)) # the width of cell is 2 characters thick
    y=$((posy + ly))

    "$mask"                                         &&
    [ "$y" -ge "$PLAYFIELD_Y" ]                     &&
    [ "$y" -lt $((PLAYFIELD_Y + PLAYFIELD_H)) ]     &&
    [ "$x" -ge "$PLAYFIELD_X" ]                     &&
    [ "$x" -lt $((PLAYFIELD_X + PLAYFIELD_W * 2)) ] && xyprint $x $y "$content" # draw mino within playfield
    "$mask"                                         || xyprint $x $y "$content"

    shift 2
  done
}

draw_current() {
  # Arguments: 1 - string to draw single cell
  # factor 2 for x because each cell is 2 characters wide
  draw_piece $((PLAYFIELD_X + current_piece_x * 2)) $((PLAYFIELD_Y + PLAYFIELD_H - 1 - current_piece_y)) $current_piece $current_piece_rotation "$1" true
}

show_current() {
  local color
  ${current_piece+:} return
  eval color=\"\$piece_"$current_piece"_color\"
  set_fg "$color"
  set_bg "$color"
  draw_current "$filled_cell"
  reset_colors
}

clear_current() {
  draw_current "$empty_cell"
}

draw_next() {
  # Arguments: 1 - visibility ( false - no, true - yes)
  local color visible x y content

  x="$NEXT_X"; y="$NEXT_Y"; visible="$1"
  shift $#
  set $next_queue
  while [ $# -gt 0 ]; do
    content='  '
    "$visible" && {
      eval color=\"\$piece_"$1"_color\"
      set_fg "$color"
      set_bg "$color"
      content="$filled_cell"
    }
    draw_piece "$x" "$y" "$1" "$NORTH" "$content"
    "$visible" && reset_colors
    shift
    y=$((y + 3))
  done
}

show_next() {
  draw_next true
}

clear_next() {
  draw_next false
}

draw_hold() {
  # Arguments: 1 - visibility ( false - no, true - yes)
  local visible="$1" color

  [ -z "$hold_queue" ] && return

  content='  '
  "$visible" && {
    eval color=\"\$piece_"$hold_queue"_color\"
    set_fg "$color"
    set_bg "$color"
    content="$filled_cell"
  }
  draw_piece $((HOLD_X)) $((HOLD_Y)) $hold_queue "$NORTH" "$content"
  "$visible" && reset_colors
}

show_hold() {
  draw_hold true
}

clear_hold() {
  draw_hold false
}

draw_border() {
  local x1 x2 y1 y2 i x y

  set_bold
  set_fg $BORDER_COLOR
  x1=$((PLAYFIELD_X - 1))               # 1 here is because border is 1 characters thick
  x2=$((PLAYFIELD_X + PLAYFIELD_W * 2)) # 2 here is because each cell on play field is 2 characters wide
  y1=$((PLAYFIELD_Y - 1))
  y2=$((PLAYFIELD_Y + PLAYFIELD_H))

  i=0
  while [ "$i" -lt "$PLAYFIELD_H" ]; do
    y=$((i + PLAYFIELD_Y))
    xyprint $x1 $y "│"
    xyprint $x2 $y "│"
    i=$((i + 1))
  done
  
  i=0
  while [ "$i" -lt "$PLAYFIELD_W" ]; do
    x=$((i * 2 + PLAYFIELD_X)) # 2 here is because each cell on play field is 2 characters width
    xyprint $x $y1 '──'
    xyprint $x $y2 '──'
    i=$((i + 1))
  done
  
  xyprint $x1 $y1 "┌"; xyprint $x2 $y1 "┐" # draw the corners
  xyprint $x1 $y2 "└"; xyprint $x2 $y2 "┘"

  reset_colors
}

draw_help() {
  # Arguments: 1 - visibility ( false - no, true - yes), if this argument is skipped $help_on is used
  local visible=${1:-$help_on} x y line

  x="$HELP_X"; y="$HELP_Y"

  set_bold
  set_fg "$HELP_COLOR"

  additional_buffer=$(
    echo "$help" | {
      # in this process, the change of screen_buffer is ignored out of this process. 
      # should return the buffer.
      screen_buffer=''
      while read line; do
        "$visible" || {
          empty_line=''; i=0
          while [ "$i" -lt ${#line} ]; do empty_line="$empty_line "; i=$((i + 1)); done
          line="$empty_line"
        }
        eval xyprint \"$x\" \"$y\" \'"$line"\'
        y=$((y + 1))
      done
      echo "$screen_buffer"
    }
  )
  puts "$additional_buffer"
  reset_colors
}

refresh_screen() {
  clear
  redraw_screen
}

redraw_screen() {
  draw_help                   # should first. draw help on the lowest layer
  show_next
  show_hold
  update_score "$ACTION_NONE"
  draw_border
  redraw_playfield
  show_current
}

toggle_help() {
  $help_on && help_on=false || help_on=true
  draw_help
}

toggle_beep() {
  $beep_on && beep_on=false || beep_on=true
  beep
}

toggle_color() {
  $no_color && no_color=false || no_color=true
  redraw_screen 
}

quit() {
  showtime=false                               # let's stop controller ...
  send_signal $SIGNAL_TERM $timer_pid          # let's kill ticker process ...
  send_signal $SIGNAL_TERM $reader_pid         #
  send_signal $SIGNAL_TERM $ticker_pid         #
  xyprint $GAMEOVER_X $GAMEOVER_Y 'Game Over!'
  xyprint 0 $((PLAYFIELD_Y + PLAYFIELD_H)) '
> Quit
> Press any key to continue ...'               # put message at bottom of playfield so that game screen will keep its shape.
  flush_screen
}

init() {
  local x y i from cmd pid statement

  echo 'Loading...'
  # playfield is initialized with -1s (empty cells)
  # x of playfield - 0, ..., (PLAYFIELD_W-1)
  # y of playfield - 0, ..., (PLAYFIELD_H-1), ..., (START_Y)
  # (0, 0) is bottom left
  y=0
  while [ "$y" -le "$START_Y" ]; do
    x=0
    while [ "$x" -lt "$PLAYFIELD_W" ]; do
      eval playfield_"$y"_"$x"=-1
      x=$((x + 1))
    done
    y=$((y + 1))
  done

  # prepare next queue filled with NEXT_MAX tetrimino 
  i=0
  while [ "$i" -lt "$NEXT_MAX" ]; do
    feed_next_queue
    i=$((i + 1))
  done

  $debug && echo 'Checking subprocess pid'
  ticker_pid=''; timer_pid=''; reader_pid=''
  while [ -z $ticker_pid ] || [ -z $timer_pid ] || [ -z $reader_pid ]; do
    read statement
    shift $#; set $statement
    [ $# -lt 4 ] && continue
    from=$2; cmd=$3; pid=$4

    [ $cmd -eq $MY_PID ] && {
      case $from in
        $PROCESS_TICKER)
          ticker_pid=$4
          $debug &&  echo "> ticker $ticker_pid ...OK"
          ;;
        $PROCESS_READER)
          reader_pid=$4
          $debug &&  echo "> reader $reader_pid ...OK"
          ;;
        $PROCESS_TIMER)
          timer_pid=$4
          $debug &&  echo "> timer  $timer_pid ...OK"
          ;;
      esac
    }
  done

  $debug && echo "Leveling up to $starting_level"
  $debug && printf "> $level "
  # level up until reach starting level
  while [ $level -lt $starting_level ]; do
    level_up
    $debug && printf "$level "
    while read statement; do
      shift $#; set $statement
      [ $# -eq 3 ]               &&
      [ $2 -eq $PROCESS_TICKER ] &&
      [ $3 -eq $ACK ]            && {
        break
      }
    done
    sleep 0.1
  done
  $debug && echo " ...OK"

  clear
  hide_cursor
  redraw_screen
  xyprint $((READY_X - 3)) $READY_Y 'READY'
  flush_screen
  sleep 1

  # counting down 3 seconds
  i=3
  while [ $i -gt 0 ]; do
    xyprint $((READY_X - 1)) $((READY_Y + 1)) $i
    flush_screen
    sleep 1
    i=$((i - 1))
  done

  get_next
  redraw_screen
  flush_screen
}

lockdown_timer() {
  # on SIGTERM this process should exit
  trap exit $SIGNAL_TERM
  # on this signal reset the timer. lockdown 0.5~0.6(0.5 is correct) sec after receiving signal
  trap 'trigger_counter=5'  $SIGNAL_RESTART_LOCKDOWN_TIMER
  trap 'trigger_counter=-1' $SIGNAL_CANCEL_LOCKDOWN_TIMER

  local trigger_counter timestamp

  get_pid my_pid
  echo "$(now) $PROCESS_TIMER $MY_PID $my_pid"

  trigger_counter=-1  # -1 - already triggerd; 0 - triggered; greater than 0 - count to trigger
  while true; do
    
    [ "$trigger_counter" -eq 0 ] && {
      timestamp=''
      while [ -z "$timestamp" ]; do # in some case, timestamp suddenly becomes empty string. I dont know why ;-)
        timestamp=$(now)            # so get time again...
      done
      [ "$trigger_counter" -gt 0 ] && continue # final check
      trigger_counter=-1
      # echo 'Fire Lock' >> .log # for debugging to check when signal fired.
      echo "$timestamp $PROCESS_TIMER $LOCKDOWN"
    }
    [ "$trigger_counter" -gt 0 ] && trigger_counter=$((trigger_counter - 1))

    sleep 0.1 & # wait in background for receiving the signal 
    wait
  done
}

# this function runs in separate process
# it sends DOWN commands to controller with appropriate delay
ticker() {
  # on SIGTERM this process should exit
  trap exit $SIGNAL_TERM
  # on this signal fall speed should be increased, this happens during level ups
  trap 'level=$((level + 1)); echo "$(now) $PROCESS_TICKER $ACK"' $SIGNAL_LEVEL_UP

  get_pid my_pid
  echo "$(now) $PROCESS_TICKER $MY_PID $my_pid"

  # the game level, which levelup-signal counts up.
  level=1
  while true ; do
    eval sleep \"\$FALL_SPEED_LEVEL_$level\" &
    wait
    echo "$(now) $PROCESS_TICKER $FALL" # <timestamp> <cmd>
    # echo "$level" >> .log # For debuging. check level variable
  done
}

# this function processes keyboard input
reader() {
  # this process exits on SIGTERM
  trap exit $SIGNAL_TERM

  local key a='' b='' esc_ch='1b' cmd

  get_pid my_pid
  echo "$(now) $PROCESS_READER $MY_PID $my_pid"

  stty -echo # disable terminal local echo (echoback)
  while true ;do
    # read one key, and convert to hex value
    key=$(stty -icanon; dd ibs=1 count=1 2>/dev/null | od -An -tx1)
    key=$(echo $key) # Strip whitespace from the beginning and end of a string
    cmd=''
    # echo "$a$b$key" # For debugging to check the input sequence.
    case "$a$b$key" in
      *"$esc_ch""$esc_ch") # 2 escapes
        cmd="$QUIT"
        ;;
      *"$esc_ch"'5b41')    # 'up-cursor'
        cmd="$ROTATE_CW"
        ;;
      *"$esc_ch"'5b42')    # 'down-cursor'
        cmd="$SOFT_DROP"
        ;;
      *"$esc_ch"'5b43')    # 'right-cursor'
        cmd="$RIGHT"
        ;;
      *"$esc_ch"'5b44')    # 'left-cursor'
        cmd="$LEFT"
        ;;
      *'20')               # ' '
        cmd="$HARD_DROP"
        ;;
      *'63')               # 'c'
        cmd="$HOLD"
        ;;
      *'78')               # 'x'
        cmd="$ROTATE_CW"
        ;;
      *'7a')               # 'z'
        cmd="$ROTATE_CCW"
        ;;
      *'42')               # 'B'
        cmd="$TOGGLE_BEEP"
        ;;
      *'43')               # 'C'
        cmd="$TOGGLE_COLOR"
        ;;
      *'52')               # 'R'
        cmd="$REFRESH_SCREEN"
        ;;
      *'48')               # 'H'
        cmd="$TOGGLE_HELP"
        ;;
      *'51')               # 'Q'
        cmd="$QUIT"
        ;;
    esac
    a=$b   # preserve previous keys
    b=$key
    [ -n "$cmd" ] && echo "$(now) $PROCESS_READER $cmd" # if not empty string
  done
}

controller() {
  # These signals are ignored
  trap '' $SIGNAL_TERM
  local cmd statement issued_time from

  # initialization of commands array with appropriate functions
  eval commands_"$QUIT"=quit
  eval commands_"$RIGHT"=move_right
  eval commands_"$LEFT"=move_left
  eval commands_"$ROTATE_CW"=rotate_cw
  eval commands_"$ROTATE_CCW"=rotate_ccw
  eval commands_"$FALL"=fall
  eval commands_"$SOFT_DROP"=soft_drop
  eval commands_"$HARD_DROP"=hard_drop
  eval commands_"$HOLD"=hold
  eval commands_"$REFRESH_SCREEN"=refresh_screen
  eval commands_"$TOGGLE_BEEP"=toggle_beep
  eval commands_"$TOGGLE_COLOR"=toggle_color
  eval commands_"$TOGGLE_HELP"=toggle_help
  eval commands_"$LOCKDOWN"=lockdown

  init
  discard_cmds
  
  while $showtime; do # run while showtime variable is true, it is changed to false in quit function
    # read next command from stdout
    # skip cmds issued before discard_cmds_timepoint
    while read statement; do
      shift $#; set $statement
      [ $# -lt 3 ] && continue   # validate param counts is 3 or more
      issued_time="$1"; from="$2" cmd="$3"
      [ "$issued_time" -gt "$discard_cmds_timepoint" ] && break
    done
    case $cmd in
      "$ACK"|"$MY_PID")              ;; # ignore
      *) 
        eval eval \"\$commands_"$cmd"\" # run command
        flush_screen
        ;; 
    esac
  done
}

game() {
  stty_g=`stty -g`                        # let's save terminal state

  # output of ticker, timer and reader is joined and piped into controller
  (
    ticker         & # runs as separate process
    lockdown_timer &
    reader
  ) | (
    controller
  )

  echo ''        # add new line
  show_cursor
  stty "$stty_g" # let's restore terminal state
}

main() {
  rotate_piece_func=rotate_piece_super
  starting_level=1
  debug=false
  while [ $# -gt 0 ]; do
    case $1 in
      -d|--debug)
        debug=true
        shift; continue
        ;;
      -l|--level)
        [ $# -le 1 ]                                    || # if next parameter not exists...
        { expr $2 + 1 > /dev/null 2>&1; [ $? -gt 1 ]; } || # ...not number
        [ $2 -lt 1 ]                                    || # ...less than 1
        [ $2 -gt $LEVEL_MAX ]                           && # ...greater than LEVEL_MAX, then exit
        {
          echo "${0##*/}: invalid level '$2'" 1>&2
          echo "$usage" 1>&2; exit 1
        }

        starting_level=$2
        shift 2; continue
        ;;
      --rotation)
        [ $# -le 1 ] && {
          echo "${0##*/}: option '$1' requires an argument" 1>&2
          echo "$usage" 1>&2; exit 1
        }
        case $2 in
          classic) rotate_piece_func=rotate_piece_classic ;;
          super)   rotate_piece_func=rotate_piece_super   ;;
          *)
            echo "${0##*/}: unrecognized rotation mode '$2'" 1>&2
            echo "$usage" 1>&2; exit 1
            ;;
        esac
        shift 2; continue
        ;;
      --lockdown)
        [ $# -le 1 ] && {
          echo "${0##*/}: option '$1' requires an argument" 1>&2
          echo "$usage" 1>&2; exit 1
        }
        case $2 in
          extended) lockdown_rule=$LOCKDOWN_RULE_EXTENDED ;;
          infinite) lockdown_rule=$LOCKDOWN_RULE_INFINITE ;;
          classic)  lockdown_rule=$LOCKDOWN_RULE_CLASSIC  ;;
          *)
            echo "${0##*/}: unrecognized lockdown rule '$2'" 1>&2
            echo "$usage" 1>&2; exit 1
            ;;
        esac
        shift 2; continue
        ;;
      --no-beep)
        no_beep=true
        shift; continue
        ;;
      --no-color)
        no_color=true
        shift; continue
        ;;
      --hide-help)
        help_on=false
        shift; continue
        ;;
      --help|-h)    echo "$usage";   exit ;;
      --version|-V) echo "$VERSION"; exit ;;
      *)
        echo "${0##*/}: unrecognized option '$1'" 1>&2
        echo "$usage" 1>&2; exit 1
        ;;
    esac
  done

  if $debug; then
    game
  else
    game 2> /dev/null # discard stderr of kill command saying 'User defined signal ...'
  fi
}

main "$@"