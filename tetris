#!/bin/sh

# Tetris game written in pure sh
#
# I tried to follow the Tetris Guideline(2009).
# URL: [Tetris Guideline. Tetris Wiki. accessed at 2020-05-23](https://tetris.fandom.com/wiki/Tetris_Guideline)
#
# This script is based on bash-tetris (Author: Kirill Timofeev <kt97679@gmail.com>)
# Thank you!
#
# I implemented
#
# * Hold Queue
# * Next Queue
# * Random Generation with Bag System
# * Score System
# * Variable Goal System
# * T-Spin / Mini T-Spin
# * Back-to-Back Bonus
# * Extended Placement / Infinite Placement / Classic Lock Down
# * Super / Classic Rotation System
# * Changing the Starting Level
# * Ghost Piece
#
# Enjoy :-)
#
# Supported Environments:
#   Linux   sh | o
#   FreeBSD sh | o
#   BusyBox sh | o
#   Solaris sh | o (Almost work)
#
# Github Page:
#   <https://github.com/ContentsViewer/sh-tetris>
#
# Author:
#   IOE <Github: ContentsViewer>
#
# Scripting NOTE:
#   * We cannot use `read -s -n 1`
#   * Any process cannot send signals to control(main) process
#     * stty issues error -> cannot read keyboard inputs
#
#   * Avoid using `trap` and background `sleep` together.
#     ```
#       trap 'printf .' USR1
#
#       while true; do
#         sleep 0.01 & wait $!
#       done
#     ```
#
#     On macOS (bash 3.2.57), an "Illegal instruction: 4" error occured
#     and program stopped.
#

set -u # non initialized variable is an error

# game versioin
# should follow "Semantic Versioning 2.0.0" <https://semver.org/>
# so that users have a clear indicator of when an upgrade will introduce breaking changes.
VERSION='2.2.0-alpha'

# program name
PROG=${0##*/}

# the year the game was created.
# displayed in COPYRIGHT.
CREATED_YEAR='2021'

# Game must have this notice when the game starts.
COPYRIGHT="
────────────────────────────────────────────────────────────────────────────────
Tetris (c) 1985~${CREATED_YEAR} Tetris Holding.
Tetris logos, Tetris theme song and Tetriminos are trademarks of Tetris Holding.
The Tetris trade dress is owned by Tetris Holding.
Licensed to The Tetris Company.
Tetris Game Design by Alexey Pajitnov.
Tetris Logo Design by Roger Dean.
All Rights Reserved.
────────────────────────────────────────────────────────────────────────────────
"

# Explicitly reset to the default value to prevent the import of IFS
# from the environment. The following shells will work more safely.
#   dash <= 0.5.10.2, FreeBSD sh <= 10.4, etc.
IFS=$(printf ' \t\n_') && IFS=${IFS%_}
LF=${IFS#??}

if [ "${ZSH_VERSION:-}" ]; then
  IFS="$IFS"$'\0'    # Default IFS value for zsh.
  setopt shwordsplit # Required for zsh support.
fi

# Log file to be written for debug.
# the contents in the file will not be deleted,
# but always written in appending.
LOG='.log'

# these signals are used for communicating with each process(i.e. reader, timer, ticker, controller).
# Note:
#   in shell enviroment, should Drop the SIG prefix, just input the signal name.
SIGNAL_TERM=TERM
SIGNAL_INT=INT
SIGNAL_LEVEL_UP=USR1
SIGNAL_RESET_LEVEL=USR2
SIGNAL_CANCEL_LOCKDOWN_TIMER=USR1
SIGNAL_RESTART_LOCKDOWN_TIMER=USR2

# Those are commands sent to controller by key press processing code
# In controller they are used as index to retrieve actual function from array
QUIT=0
RIGHT=1
LEFT=2
FALL=3
SOFT_DROP=4
HARD_DROP=5
ROTATE_CW=6
ROTATE_CCW=7
HOLD=8
TOGGLE_BEEP=9
TOGGLE_COLOR=10
TOGGLE_HELP=11
REFRESH_SCREEN=12
LOCKDOWN=13
MY_PID=14

PROCESS_CONTROLLER=0
PROCESS_TICKER=1
PROCESS_TIMER=2
PROCESS_READER=3

BEHAVIOUR_NON=0
BEHAVIOUR_RIGHT=1
BEHAVIOUR_LEFT=2
BEHAVIOUR_ROTATE=3
BEHAVIOUR_FALL=4
BEHAVIOUR_SOFT_DROP=5
BEHAVIOUR_HARD_DROP=6

# The normal Fall Speed is defined here to be the time it takes a Tetrimino to fall by one line.
# The current level of the game determines the normal Fall Speed using the following equation:
# (0.8 - ((level - 1) * 0.007))^(level-1)
FALL_SPEED_LEVEL_1=1
FALL_SPEED_LEVEL_2=0.793
FALL_SPEED_LEVEL_3=0.618
FALL_SPEED_LEVEL_4=0.473
FALL_SPEED_LEVEL_5=0.355
FALL_SPEED_LEVEL_6=0.262
FALL_SPEED_LEVEL_7=0.190
FALL_SPEED_LEVEL_8=0.135
FALL_SPEED_LEVEL_9=0.094
FALL_SPEED_LEVEL_10=0.064
FALL_SPEED_LEVEL_11=0.043
FALL_SPEED_LEVEL_12=0.028
FALL_SPEED_LEVEL_13=0.018
FALL_SPEED_LEVEL_14=0.011
FALL_SPEED_LEVEL_15=0.007
LEVEL_MAX=15

# color codes
RED=1
GREEN=2
YELLOW=3
BLUE=4
MAGENTA=5
CYAN=6
WHITE=7
ORANGE=208

# Those are Tetrimino type
O_TETRIMINO=0
I_TETRIMINO=1
T_TETRIMINO=2
L_TETRIMINO=3
J_TETRIMINO=4
S_TETRIMINO=5
Z_TETRIMINO=6

# Those are the facing
# Tetrimino has four facings
NORTH=0
EAST=1
SOUTH=2
WEST=3

ACTION_NONE=0
ACTION_SINGLE=1
ACTION_DOUBLE=2
ACTION_TRIPLE=3
ACTION_TETRIS=4
ACTION_SOFT_DROP=5
ACTION_HARD_DROP=6
ACTION_TSPIN=7
ACTION_TSPIN_SINGLE=8
ACTION_TSPIN_DOUBLE=9
ACTION_TSPIN_TRIPLE=10
ACTION_MINI_TSPIN=11
ACTION_MINI_TSPIN_SINGLE=12

eval SCORE_FACTOR_"$ACTION_NONE"=0
eval SCORE_FACTOR_"$ACTION_SINGLE"=100
eval SCORE_FACTOR_"$ACTION_DOUBLE"=300
eval SCORE_FACTOR_"$ACTION_TRIPLE"=500
eval SCORE_FACTOR_"$ACTION_TETRIS"=800
eval SCORE_FACTOR_"$ACTION_TSPIN"=400
eval SCORE_FACTOR_"$ACTION_TSPIN_SINGLE"=800
eval SCORE_FACTOR_"$ACTION_TSPIN_DOUBLE"=1200
eval SCORE_FACTOR_"$ACTION_TSPIN_TRIPLE"=1600
eval SCORE_FACTOR_"$ACTION_MINI_TSPIN"=100
eval SCORE_FACTOR_"$ACTION_MINI_TSPIN_SINGLE"=200
eval SCORE_FACTOR_"$ACTION_SOFT_DROP"=1
eval SCORE_FACTOR_"$ACTION_HARD_DROP"=2

# A Tetrimino that is Hard Dropped Locks Down immediately. However, if a Tetrimino naturally falls
# or Soft Drops onto a Surface, it is given 0.5 seconds on a Lock Down Timer before it actually
# Locks Down. Three rulesets —Infinite Placement, Extended, and Classic— dictate the conditions
# for Lock Down. The default is Extended Placement.
#
# Extended Placement Lock Down
#   This is the default Lock Down setting.
#   Once the Tetrimino in play lands on a Surface in the Matrix, the Lock Down Timer starts counting
#   down from 0.5 seconds. Once it hits zero, the Tetrimino Locks Down and the Next Tetrimino’s
#   generation phase starts. The Lock Down Timer resets to 0.5 seconds if the player simply moves
#   or rotates the Tetrimino. In Extended Placement, a Tetrimino gets 15 left/right movements or
#   rotations before it Locks Down, regardless of the time left on the Lock Down Timer. However, if
#   the Tetrimino falls one row below the lowest row yet reached, this counter is reset. In all other
#   cases, it is not reset.
#
# Infinite Placement Lock Down
#   Once the Tetrimino in play lands on a Surface in the Matrix, the Lock Down Timer starts counting
#   down from 0.5 seconds. Once it hits zero, the Tetrimino Locks Down and the Next Tetrimino’s
#   generation phase starts. However, the Lock Down Timer resets to 0.5 seconds if the player simply
#   moves or rotates the Tetrimino. Thus, Infinite Placement allows the player to continue movement
#   and rotation of a Tetrimino as long as there is an actual change in its position or orientation
#   before the timer expires.
#
# Classic Lock Down
#   Classic Lock Down rules apply if Infinite Placement and Extended Placement are turned off.
#   Like Infinite Placement, the Lock Down Timer starts counting down from 0.5 seconds once the
#   Tetrimino in play lands on a Surface. The y-coordinate of the Tetrimino must decrease (i.e., the
#   Tetrimino falls further down in the Matrix) in order for the timer to be reset.
LOCKDOWN_RULE_EXTENDED=0
LOCKDOWN_RULE_INFINITE=1
LOCKDOWN_RULE_CLASSIC=2
LOCKDOWN_ALLOWED_MANIPULATIONS=15

# Location and size of playfield, color and border
PLAYFIELD_W=10
PLAYFIELD_H=20
PLAYFIELD_X=18
PLAYFIELD_Y=2
BORDER_COLOR=$WHITE

# Location and color of score information
SCORE_X=3
SCORE_Y=6
SCORE_COLOR=$GREEN

# Location and color of help information
HELP_X=52
HELP_Y=10
HELP_COLOR=$YELLOW

# Next piece location
NEXT_X=41
NEXT_Y=2
NEXT_MAX=7

# Hold piece location
HOLD_X=7
HOLD_Y=2

# Location of 'Game Over!' at end of the game
GAMEOVER_X=$((PLAYFIELD_X + PLAYFIELD_W - 5))  # 1 width equals 2 character
GAMEOVER_Y=$((PLAYFIELD_Y + PLAYFIELD_H / 2))

# Location of center of play field.
CENTER_X=$((PLAYFIELD_X + PLAYFIELD_W))
CENTER_Y=$((PLAYFIELD_Y + PLAYFIELD_H / 2))

# piece starting location
# Tetriminos are all generated North Facing (just as they appear in the Next Queue) on the 21st
# and 22nd rows, just above the Skyline. There are 10 cells across the Matrix, and every Tetrimino
# that is three Minos wide is generated on the 4th cell across and stretches to the 6th. This
# includes the T-Tetrimino, L-Tetrimino, J-Tetrimino, S-Tetrimino and Z-Tetrimino. The I-Tetrimino and
# O-Tetrimino are exactly centered at generation. The I-Tetrimino is generated on the 21st row
# (not 22nd), stretching from the 4th to 7th cells. The O-Tetrimino is generated on the 5th and
# 6th cell.
START_X=3
START_Y=21

# assured over 3 blocks above START_Y
BUFFER_ZONE_Y=24

# loading spin sequence
LOADING_SPIN='/ - \ |'

# constant chars
ESC_CH="$(printf '\033')"

# this array holds all possible pieces that can be used in the game
# each piece consists of 4 cells(minos)
# each string is sequence of relative xy coordinates
# Format:
#   piece_<TETRIMINO>_minos_<FACING>='<mino_0_x> <mino_1_y> ...'
#     (0, 0) is top left
#
# rotation shifts
#   piece_<TETRIMINO>_rchifts_<FACING>='<POINT_1> <POINT_2> ...'
#     <POINT_<NO>>: <ROTATION_LEFT_shifts> <ROTATION_RIGHT_shifts>
#     <ROTATION_<DIR>_shifts>: <shift_x> <shift_y>
#

# O-Tetrimino
eval piece_"$O_TETRIMINO"_color=\"$YELLOW\"
eval piece_"$O_TETRIMINO"_minos_"$NORTH"=\'1 0  2 0  1 1  2 1\'
eval piece_"$O_TETRIMINO"_minos_"$EAST"=\' 1 0  2 0  1 1  2 1\'
eval piece_"$O_TETRIMINO"_minos_"$SOUTH"=\'1 0  2 0  1 1  2 1\'
eval piece_"$O_TETRIMINO"_minos_"$WEST"=\' 1 0  2 0  1 1  2 1\'
eval piece_"$O_TETRIMINO"_rshifts_"$NORTH"=\"0  0  0  0   0  0  0  0   0  0  0  0   0  0  0  0   0  0  0  0\"
eval piece_"$O_TETRIMINO"_rshifts_"$EAST"=\" 0  0  0  0   0  0  0  0   0  0  0  0   0  0  0  0   0  0  0  0\"
eval piece_"$O_TETRIMINO"_rshifts_"$SOUTH"=\"0  0  0  0   0  0  0  0   0  0  0  0   0  0  0  0   0  0  0  0\"
eval piece_"$O_TETRIMINO"_rshifts_"$WEST"=\" 0  0  0  0   0  0  0  0   0  0  0  0   0  0  0  0   0  0  0  0\"

# I-Tetrimino
eval piece_"$I_TETRIMINO"_color=\"$CYAN\"
eval piece_"$I_TETRIMINO"_minos_"$NORTH"=\'0 1  1 1  2 1  3 1\'
eval piece_"$I_TETRIMINO"_minos_"$EAST"=\' 2 0  2 1  2 2  2 3\'
eval piece_"$I_TETRIMINO"_minos_"$SOUTH"=\'0 2  1 2  2 2  3 2\'
eval piece_"$I_TETRIMINO"_minos_"$WEST"=\' 1 0  1 1  1 2  1 3\'
eval piece_"$I_TETRIMINO"_rshifts_"$NORTH"=\"0  0  0  0  -1  0 -2  0   2  0  1  0  -1  2 -2 -1   2 -1  1  2\"
eval piece_"$I_TETRIMINO"_rshifts_"$EAST"=\" 0  0  0  0   2  0 -1  0  -1  0  2  0   2  1 -1  2  -1 -2  2 -1\"
eval piece_"$I_TETRIMINO"_rshifts_"$SOUTH"=\"0  0  0  0   1  0  2  0  -2  0 -1  0   1 -2  2  1  -2  1 -1 -2\"
eval piece_"$I_TETRIMINO"_rshifts_"$WEST"=\" 0  0  0  0  -2  0  1  0   1  0 -2  0  -2 -1  1 -2   1  2 -2  1\"

# T-Tetrimino
eval piece_"$T_TETRIMINO"_color=\"$MAGENTA\"
eval piece_"$T_TETRIMINO"_minos_"$NORTH"=\'1 0  0 1  1 1  2 1\'
eval piece_"$T_TETRIMINO"_minos_"$EAST"=\' 1 0  1 1  2 1  1 2\'
eval piece_"$T_TETRIMINO"_minos_"$SOUTH"=\'0 1  1 1  2 1  1 2\'
eval piece_"$T_TETRIMINO"_minos_"$WEST"=\' 1 0  0 1  1 1  1 2\'
eval piece_"$T_TETRIMINO"_rshifts_"$NORTH"=\"0  0  0  0   1  0 -1  0   1  1 -1  1   n  n  n  n   1 -2 -1 -2\"
eval piece_"$T_TETRIMINO"_rshifts_"$EAST"=\" 0  0  0  0   1  0  1  0   1 -1  1 -1   0  2  0  2   1  2  1  2\"
eval piece_"$T_TETRIMINO"_rshifts_"$SOUTH"=\"0  0  0  0  -1  0  1  0   n  n  n  n   0 -2  0 -2  -1 -2  1 -2\"
eval piece_"$T_TETRIMINO"_rshifts_"$WEST"=\" 0  0  0  0  -1  0 -1  0  -1 -1 -1 -1   0  2  0  2  -1  2 -1  2\"

# L-Tetrimino
eval piece_"$L_TETRIMINO"_color=\"$ORANGE\"
eval piece_"$L_TETRIMINO"_minos_"$NORTH"=\'2 0  0 1  1 1  2 1\'
eval piece_"$L_TETRIMINO"_minos_"$EAST"=\' 1 0  1 1  1 2  2 2\'
eval piece_"$L_TETRIMINO"_minos_"$SOUTH"=\'0 1  1 1  2 1  0 2\'
eval piece_"$L_TETRIMINO"_minos_"$WEST"=\' 0 0  1 0  1 1  1 2\'
eval piece_"$L_TETRIMINO"_rshifts_"$NORTH"=\"0  0  0  0   1  0 -1  0   1  1 -1  1   0 -2  0 -2   1 -2 -1 -2\"
eval piece_"$L_TETRIMINO"_rshifts_"$EAST"=\" 0  0  0  0   1  0  1  0   1 -1  1 -1   0  2  0  2   1  2  1  2\"
eval piece_"$L_TETRIMINO"_rshifts_"$SOUTH"=\"0  0  0  0  -1  0  1  0  -1  1  1  1   0 -2  0 -2  -1 -2  1 -2\"
eval piece_"$L_TETRIMINO"_rshifts_"$WEST"=\" 0  0  0  0  -1  0 -1  0  -1 -1 -1 -1   0  2  0  2  -1  2 -1  2\"

# J-Tetrimino
eval piece_"$J_TETRIMINO"_color=\"$BLUE\"
eval piece_"$J_TETRIMINO"_minos_"$NORTH"=\'0 0  0 1  1 1  2 1\'
eval piece_"$J_TETRIMINO"_minos_"$EAST"=\' 1 0  2 0  1 1  1 2\'
eval piece_"$J_TETRIMINO"_minos_"$SOUTH"=\'0 1  1 1  2 1  2 2\'
eval piece_"$J_TETRIMINO"_minos_"$WEST"=\' 1 0  1 1  0 2  1 2\'
eval piece_"$J_TETRIMINO"_rshifts_"$NORTH"=\"0  0  0  0   1  0 -1  0   1  1 -1  1   0 -2  0 -2   1 -2 -1 -2\"
eval piece_"$J_TETRIMINO"_rshifts_"$EAST"=\" 0  0  0  0   1  0  1  0   1 -1  1 -1   0  2  0  2   1  2  1  2\"
eval piece_"$J_TETRIMINO"_rshifts_"$SOUTH"=\"0  0  0  0  -1  0  1  0  -1  1  1  1   0 -2  0 -2  -1 -2  1 -2\"
eval piece_"$J_TETRIMINO"_rshifts_"$WEST"=\" 0  0  0  0  -1  0 -1  0  -1 -1 -1 -1   0  2  0  2  -1  2 -1  2\"

# S-Tetrimino
eval piece_"$S_TETRIMINO"_color=\"$GREEN\"
eval piece_"$S_TETRIMINO"_minos_"$NORTH"=\'1 0  2 0  0 1  1 1\'
eval piece_"$S_TETRIMINO"_minos_"$EAST"=\' 1 0  1 1  2 1  2 2\'
eval piece_"$S_TETRIMINO"_minos_"$SOUTH"=\'1 1  2 1  0 2  1 2\'
eval piece_"$S_TETRIMINO"_minos_"$WEST"=\' 0 0  0 1  1 1  1 2\'
eval piece_"$S_TETRIMINO"_rshifts_"$NORTH"=\"0  0  0  0   1  0 -1  0   1  1 -1  1   0 -2  0 -2   1 -2 -1 -2\"
eval piece_"$S_TETRIMINO"_rshifts_"$EAST"=\" 0  0  0  0   1  0  1  0   1 -1  1 -1   0  2  0  2   1  2  1  2\"
eval piece_"$S_TETRIMINO"_rshifts_"$SOUTH"=\"0  0  0  0  -1  0  1  0  -1  1  1  1   0 -2  0 -2  -1 -2  1 -2\"
eval piece_"$S_TETRIMINO"_rshifts_"$WEST"=\" 0  0  0  0  -1  0 -1  0  -1 -1 -1 -1   0  2  0  2  -1  2 -1  2\"

# Z-Tetrimino
eval piece_"$Z_TETRIMINO"_color=\"$RED\"
eval piece_"$Z_TETRIMINO"_minos_"$NORTH"=\"0 0  1 0  1 1  2 1\"
eval piece_"$Z_TETRIMINO"_minos_"$EAST"=\" 2 0  1 1  2 1  1 2\"
eval piece_"$Z_TETRIMINO"_minos_"$SOUTH"=\"0 1  1 1  1 2  2 2\"
eval piece_"$Z_TETRIMINO"_minos_"$WEST"=\" 1 0  0 1  1 1  0 2\"
eval piece_"$Z_TETRIMINO"_rshifts_"$NORTH"=\"0  0  0  0   1  0 -1  0   1  1 -1  1   0 -2  0 -2   1 -2 -1 -2\"
eval piece_"$Z_TETRIMINO"_rshifts_"$EAST"=\" 0  0  0  0   1  0  1  0   1 -1  1 -1   0  2  0  2   1  2  1  2\"
eval piece_"$Z_TETRIMINO"_rshifts_"$SOUTH"=\"0  0  0  0  -1  0  1  0  -1  1  1  1   0 -2  0 -2  -1 -2  1 -2\"
eval piece_"$Z_TETRIMINO"_rshifts_"$WEST"=\" 0  0  0  0  -1  0 -1  0  -1 -1 -1 -1   0  2  0  2  -1  2 -1  2\"

eval T_TETRIMINO_"$NORTH"_SIDES=\"0 0  2 0  0 2  2 2\"
eval T_TETRIMINO_"$EAST"_SIDES=\" 2 0  0 2  0 0  0 2\"
eval T_TETRIMINO_"$SOUTH"_SIDES=\"2 2  0 2  2 0  0 0\"
eval T_TETRIMINO_"$WEST"_SIDES=\" 0 2  0 0  2 2  2 0\"

HELP='
←         Move Left or Right
→         Move Right
↑, x      Rotate Right
z         Rotate Left
c         Hold
↓         Soft Drop
Space     Hard Drop
R         Refresh Screen
C         Toggle Color
B         Toggle Beep
H         Toggle Help
Q, ESCx2  Quit
'

USAGE="
Usage: $PROG [options]

Options:
 -d, --debug          debug mode
 -l, --level <LEVEL>  game level (default=1). range from 1 to $LEVEL_MAX
 --rotation <MODE>    use 'Super' or 'Classic' rotation system
                      MODE can be 'super'(default) or 'classic'
 --lockdown <RULE>    Three rulesets —Infinite Placement, Extended, and Classic—
                      dictate the conditions for Lock Down.
                      RULE can be 'extended'(default), 'infinite', 'classic'
 --seed <SEED>        random seed to determine the order of Tetriminos.
                      range from 1 to 4294967295.
 --no-color           don't display colors
 --no-beep            disable beep
 --hide-help          don't show help on start

 -h, --help     display this help and exit
 -V, --version  output version infromation and exit

Version:
 $VERSION
"

# the queue of the next tetriminos to be placed.
# the reference says the next six tetrimonos should be shown.
next_queue=''

# the hold queue allows the player to hold a falling tetrimino for as long as they wish.
hold_queue=''

# Tetris uses a “bag” system to determine the sequence of Tetriminos that appear during game
# play. This system allows for equal distribution among the seven Tetriminos.
#
# The seven different Tetriminos are placed into a virtual bag, then shuffled into a random order.
# This order is the sequence that the bag “feeds” the Next Queue. Every time a new Tetrimino is
# generated and starts its fall within the Matrix, the Tetrimino at the front of the line in the bag is
# placed at the end of the Next Queue, pushing all Tetriminos in the Next Queue forward by one.
# The bag is refilled and reshuffled once it is empty.
bag=''

# Note: In most competitive multiplayer variants, all players should receive the same order of
# Tetriminos (random for each game played), unless the variant is specifically designed not to
# do this.
#
# Tetriminoes will appear in the same order in games started with the same number.
# 0 means not set, and the range is from 1 to 4294967295.
bag_random=0

# the Variable Goal System requires that the player clears 5 lines at level 1, 10 lines at
# level 2, 15 at level 3 and so on, adding an additional five lines to the Goal each level through 15.
# with the Variable Goal System of adding 5 lines per level, the player is required to clear 600 lines
# by level 15.
#
# This system also includes line bonuses to help speed up the game.
# To speed up the process of “clearing” 600 lines, in the Variable Goal System the number of Line
# Clears awarded for any action is directly based off the score of the action performed (score
# at level 1 / 100 = Total Line Clears
adding_lines_per_level=5

# There is a special bonus for Back-to-Backs, which is when two actions
# such as a Tetris and T-Spin Double take place without a Single, Double, or Triple Line Clear
# occurring between them.
#
# Back-to-Back Bonus
#   Bonus for Tetrises, T-Spin Line Clears, and Mini T-Spin Line Clears
#   performed consecutively in a B2B sequence.
b2b_sequence_continues=false

lockdown_rule=$LOCKDOWN_RULE_EXTENDED

score=0                    # score variable initialization
level=0                    # level variable initialization
goal=0                     # goal variable initialization
lines_completed=0          # completed lines counter initialization
actions_to_show=''         #
already_hold=false         #
help_on=true               # if this flag is true help is shown, if false, hide
beep_on=true               #
no_color=false             # do we use color or not
running=true               # controller runs while this flag is true
discard_cmds_timepoint=0   # cmds issued before this time is discarded
empty_cell=' .'            # how we draw empty cell
filled_cell='[]'           # how we draw filled cell
ghost_cell='░░'            # how we draw ghost cell
lands_on=false             #
manipulation_counter=0     #
lowest_line=$START_X       #
current_tspin=$ACTION_NONE #

# Game Over Conditions
#
# Lock Out
#   This Game Over Condition occurs when a whole Tetrimino Locks Down above the Skyline.
#
# Block Out
#   This Game Over Condition occurs when part of a newly-generated Tetrimino is blocked due to
#   an existing Block in the Matrix

# Function for defining local variables for cross-shells support.
if (PATH=/dev/null; f() { local v; }; f) 2>/dev/null; then
  localvar() {
    set -- "$1" "$*"
    eval "$1() { local${2#"$1"}; _$1 \"\$@\"; }"
  }
else
  localvar() {
    set -- "$1" "$*"
    eval "function $1 { typeset${2#"$1"}; _$1 \"\$@\"; }"
  }
fi

# Arguments:
#   1 - varname
#   2 - str to repeat
#   3 - count
str_repeat() {
  set -- "$1" "${2:-}" "${3:-0}" ""
  while [ "$3" -gt 1 ]; do
    set -- "$1" "$2" $(($3 - 1)) "$4$2"
  done
  eval "$1=\$4\$2"
}

str_lpad() {
  set -- "$1" "$2" "$3" "${4:- }"
  while [ "${#2}" -lt "$3" ]; do
    set -- "$1" "${4}${2}" "$3" "$4"
  done
  eval "$1=\$2"
}

str_rpad() {
  set -- "$1" "$2" "$3" "${4:- }"
  while [ "${#2}" -lt "$3" ]; do
    set -- "$1" "${2}${4}" "$3" "$4"
  done
  eval "$1=\$2"
}

# screen_buffer is variable, that accumulates all screen changes
# this variable is printed in controller once per game cycle
screen_buffer=''
puts() {
  screen_buffer="$screen_buffer""$1"
}

flush_screen() {
  printf "$screen_buffer"
  screen_buffer=''
}

# move cursor to (x,y) and print string
# (1,1) is upper left corner of the screen
xyprint() {
  puts "\033[${2};${1}H${3}"
}

show_cursor() {
  printf "\033[?25h"
}

hide_cursor() {
  printf "\033[?25l"
}

# foreground color
set_fg() {
  $no_color && return
  puts "\033[38;5;${1}m"
  # puts "\033[3${1}m" # for using 8/16 Colors
}

# background color
set_bg() {
  $no_color && return
  puts "\033[48;5;${1}m"
  # puts "\033[4${1}m" # for using 8/16 Colors
}

reset_colors() {
  puts "\033[0m"
}

set_bold() {
  puts "\033[1m"
}

beep() {
  $beep_on || return
  printf '\007'
}

now() {
  date +"${1:-%s}"
}

state() {
  now "%s $1"
}

current_loading_spin_shift=0
print_loading_spin() {
  set $LOADING_SPIN
  shift $current_loading_spin_shift
  current_loading_spin_shift=$(( (current_loading_spin_shift + 1) % 4 ))
  printf '%s' "$1"
}

# Get pid of current process regardless of subshell
#
# $$:
#   Expands to the process ID of the shell.
#   In a () subshell, it expands to the process ID of the current shell, not the subshell.
#
# Notice that some shells (eg. zsh or ksh93) do NOT start a subprocess
# for each subshell created with (...); in that case, $pid may be end up
# being the same as $$, which is just right, because that's the PID of
# the process getpid was called from.
#
# ref: <https://unix.stackexchange.com/questions/484442/how-can-i-get-the-pid-of-a-subshell>
#
# usage getpid [varname]
get_pid(){
  pid=$(exec sh -c 'echo "$PPID"')
  test "$1" && eval "$1=\$pid"
}

send_signal() {
  kill -$1 $2
}

exist_process() {
  send_signal 0 "$1" 2>/dev/null
}

discard_cmds() {
  discard_cmds_timepoint=$(now)
}

# return random value (0 ~ 4294967295)
# using /dev/urandom as random seed.
# Although /dev/urandom is not defined in POSIX,
# it is enough for almost shell environment (maybe).
# (if not, considering to use `ps` as seed)
rand() {
  od -A n -t u4 -N 4 /dev/urandom | sed 's/[^0-9]//g'
}

# Generate next random value
#
# Using xorshift32 to generate random number.
# xorshit32 are a class of pseudorandom number generators.
#
# It is the recommendation of the authors of the xoshiro
# paper to initialize the state of the generators using
# a generator which is radically different from the initialized
# generators, as well as one which will never give the
# "all-zero" state; for shift-register generators,
# this state is impossible to escape from.
#
# about xorshift32:
#   * <https://en.wikipedia.org/wiki/Xorshift>
#
# Arguments:
#   1 - varname
randnext() {
  # RAND_VALUE: 32-bit (possibly signed) integer excluding 0.
  #   the sign is implementation-dependent (e.g. mksh is signed 32-bit integer).
  eval "$1=$(( $1 ^ (($1 << 13) & 4294967295) ))" # 4294967295 (0x FFFF FFFF)
  eval "$1=$(( $1 ^ (($1 >> 17) & 131071) ))"     # 131071     (0x 0001 FFFF)
  eval "$1=$(( $1 ^ (($1  << 5) & 4294967295) ))" # 4294967295 (0x FFFF FFFF)
}

# Shuffle args
#
# Using Fisher–Yates shuffle.
# details:
#   * <https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle>
#
# Arguments:
#   1    - varname to be written shuffled args
#   2    - current random value
#   3... - args to be shuffled.
localvar shuffle varname random_value shuffled len random_shift
_shuffle() {
  varname=$1 random_value=$2 shuffled=''

  shift 2 # shift to target args.

  # pick up one arg randomly and push it into 'shuffled'.
  while [ $# -gt 1 ]; do
    # get random shift (0 ~ len-1) to select arg randomly.
    randnext "$random_value"
    random_shift=$(( $random_value % $# ))

    len=${random_shift#-}       # take the absolute value
    while [ $len -gt 0 ]; do    # rotate args until selected arg comes up at head.
      set -- "$@" "$1"          # push first arg
      shift; len=$(( len - 1 )) # pop first arg
    done

    shuffled="${shuffled}${1} " # push selected arg

    shift # next selection
  done

  eval "$varname=\${shuffled}\${1}" # set result
}

reset_level() {
  level=0 goal=0 lines_completed=0
  while [ "$level" -lt "$starting_level" ]; do
    increment_level
  done
  # send reset level signal to ticker (please see ticker for more details)
  send_signal "$SIGNAL_RESET_LEVEL" "$ticker_pid"
}

level_up() {
  increment_level
  # send level-up signal to ticker (please see ticker for more details)
  send_signal "$SIGNAL_LEVEL_UP" "$ticker_pid"
}

increment_level() {
  level=$((level + 1))                            # increment level
  goal=$((goal + level * adding_lines_per_level)) # adding an additional lines to the Goal
}

fill_bag() {
  shuffle bag bag_random $O_TETRIMINO $I_TETRIMINO $T_TETRIMINO $L_TETRIMINO $J_TETRIMINO $S_TETRIMINO $Z_TETRIMINO
}

#  the Tetrimino at the front of the line in the bag is placed at the end of the Next Queue
localvar feed_next_queue poped
_feed_next_queue() {
  [ -z "$bag" ] && fill_bag       # if bag is empty, then fill the bag.
  set $bag
  poped="$1"; shift; bag="$*"     # pop the tetrimino
  next_queue="$next_queue $poped" # place tetrimino at the end of the Next Queue
}

localvar get_next next_piece
_get_next() {
  set -- $next_queue
  next_piece="$1"; # peek the next piece

  # next piece becomes current
  # place current at the top of play field.
  generate_tetrimino "$next_piece"

  # check if piece can be placed at this location, if not - game over
  new_piece_location_ok $current_piece_x $current_piece_y || quit
  show_current

  # now let's shift next queue
  clear_next
  shift; next_queue="$*" # pop the next piece from the front of queue
  feed_next_queue        # push tetrimino into queue; keep queue size
  show_next
}

hold_tetrimino() {
  #  Between Holds, A Lock Down must take place. reset this flag in move_piece().
  "$already_hold" && return
  already_hold=true

  clear_ghost

  # if hold queue is empty,
  [ -z "$hold_queue" ] && {
    hold_queue="$current_piece" # hold current tetrimino
    clear_current
    get_next                    # the Next Tetrimino is generated from the Next Queue and begins to fall
    show_hold
    return
  }
  clear_current
  clear_hold

  # swap piece
  held_piece="$hold_queue"
  hold_queue="$current_piece"

  generate_tetrimino "$held_piece"
  show_hold
}

# generate tetrimino in play field
# Arguments:
#   1 - tetrimino to generate
generate_tetrimino() {
  current_piece="$1"

  # beginning from its generation position and North Facing orientation.
  update_location $START_X $START_Y
  current_piece_rotation="$NORTH"

  current_piece_behaviour=$BEHAVIOUR_NON

  show_ghost

  lowest_line=$START_Y
  lands_on=false
}

localvar what_type_tspin pos_x pos_y rotation side_x side_y side
_what_type_tspin() {
  varname=$1 pos_x=$2 pos_y=$3 rotation=$4

  eval set -- \$T_TETRIMINO_"$rotation"_SIDES
  side=0 # 1: A; 2: B; 3: C; 4: D
  while [ $# -gt 0 ]; do
    side=$((side + 1))
    side_x=$1; side_y=$2
    side_x=$((pos_x + side_x)); side_y=$((pos_y - side_y))

    [ $side_x -lt 0 ]            ||
    [ $side_x -ge $PLAYFIELD_W ] ||
    [ $side_y -lt 0 ]            && {
      # touching wall
      eval is_touched_${side}=true
      shift 2; continue
    }

    eval field_cell="\$playfield_${side_y}_${side_x}"
    [ $field_cell -ne -1 ]       &&
    eval is_touched_${side}=true || eval is_touched_${side}=false

    shift 2
  done

  # if Sides A and B + (C or D) are touching a Surface
  # considered a T-Spin
  $is_touched_3 || $is_touched_4 && $is_touched_1 && $is_touched_2 && {
    eval "$varname=\$ACTION_TSPIN"
    return
  }

  # if Sides C and D + (A or B) are touching a Surface
  # considered a Mini T-Spin
  $is_touched_1 || $is_touched_2 && $is_touched_3 && $is_touched_4 && {
    eval "$varname=\$ACTION_MINI_TSPIN"
    return
  }

  eval "$varname=\$ACTION_NONE"
  return
}

# test if piece can be moved to new location
# Arguments:
#   1 - new x coordinate of the piece
#   2 - new y coordinate of the piece
localvar new_piece_location_ok x_test y_test x y field_cell
_new_piece_location_ok() {
  x_test="$1"; y_test="$2" # at first, we should preserve the parameters

  # set minos coordinates into parameters
  # $1 - x, $2 - y
  eval set -- \$piece_"$current_piece"_minos_"$current_piece_rotation"

  # loop through tetrimino minos: 4 minos, each has 2 coordinates
  while [ $# -gt 0 ]; do
    x=$((x_test + $1)) # new x coordinate of piece cell
    y=$((y_test - $2)) # new y coordinate of piece cell

    [ "$y" -lt 0 ]              ||
    [ "$x" -lt 0 ]              ||
    [ "$x" -ge "$PLAYFIELD_W" ] && return 1 # false; check if we are out of the play field

    eval field_cell="\$playfield_${y}_${x}"
    [ "$field_cell" != -1 ] && return 1    # false; check if location is already occupied

    shift 2 # shift to next minos coordinates
  done
  return 0
}

# this function updated occupied cells in playfield array after piece is dropped
localvar flatten_playfield color x y
_flatten_playfield() {
  eval color=\"\$piece_"$current_piece"_color\"

  # set minos coordinates into parameters
  # $1 - x, $2 - y
  eval set -- \$piece_"$current_piece"_minos_"$current_piece_rotation"

  # loop through tetrimino minos: 4 minos, each has 2 coordinates
  while [ $# -gt 0 ]; do
    x=$((current_piece_x + $1))
    y=$((current_piece_y - $2))
    eval playfield_"$y"_"$x"="$color"
    shift 2 # shift to next minos coordinates
  done
}

# check the line is completed
# Arguments:
#   1 - line y of playfield you want to check
localvar is_line_completed x line_y
_is_line_completed() {
  line_y="$1"

  x=$((PLAYFIELD_W - 1))
  while [ "$x" -ge 0 ]; do
    eval field_cell="\$playfield_${line_y}_${x}"
    [ "$field_cell" -eq -1 ] && return 1 # false. empty cell found
    x=$((x - 1))
  done;

  return 0 # true
}

# This function checks if the lines in the hot zone are complete
# and fall the upper blocks down.
#
# Arguments:
#   1 - hot zone y min
#   2 - hot zone y max (inclusive)
localvar process_complete_lines x y yi completed_lines field_cell action
_process_complete_lines() {
  completed_lines=''
  y=$1; yi=$2
  [ $y -lt 0 ] && y=0

  while [ "$y" -le "$yi" ]; do
    is_line_completed "$y" && completed_lines="$completed_lines $y"
    y=$((y + 1))
  done

  set -- $completed_lines
  [ $# -eq 0 ] && return "$ACTION_NONE"

  action="$ACTION_NONE"
  case $# in
    1) action="$ACTION_SINGLE" ;;
    2) action="$ACTION_DOUBLE" ;;
    3) action="$ACTION_TRIPLE" ;;
    4) action="$ACTION_TETRIS" ;;
    *) echo "invalid line clear" >> $LOG
  esac

  # move lines down. move cells from y to yi
  y=$1; shift
  yi=$y
  while [ "$y" -lt "$BUFFER_ZONE_Y" ]; do

    y=$((y + 1))
    [ $# -gt 0 ]      &&
    [ "$1" -eq "$y" ] && {
      shift # line y is completed.
      continue
    }

    # move line y to y1
    x=$((PLAYFIELD_W - 1))
    while [ "$x" -ge 0 ]; do
      eval field_cell="\$playfield_${y}_${x}"
      eval playfield_"$yi"_"$x"=\"$field_cell\"
      x=$((x - 1))
    done
    yi=$((yi + 1))

  done

  # now let's mark lines from line yi to top line of the playfield as free.
  while [ "$yi" -le "$BUFFER_ZONE_Y" ]; do
    x=$((PLAYFIELD_W - 1))
    while [ "$x" -ge 0 ]; do
      eval playfield_"$yi"_"$x"=-1
      x=$((x - 1))
    done
    yi=$((yi + 1))
  done

  return "$action"
}

process_fallen_piece() {
  flatten_playfield

  # There should be a line clear between current_y - 4 ~ current_y
  process_complete_lines $((current_piece_y - 4)) $current_piece_y; action="$?"

  [ $current_piece -eq $T_TETRIMINO ]                &&
  [ $current_piece_behaviour -eq $BEHAVIOUR_ROTATE ] && {
    case $current_tspin in
      $ACTION_TSPIN)
        case $action in
          $ACTION_SINGLE) action=$ACTION_TSPIN_SINGLE ;;
          $ACTION_DOUBLE) action=$ACTION_TSPIN_DOUBLE ;;
          $ACTION_TRIPLE) action=$ACTION_TSPIN_TRIPLE ;;
          $ACTION_NONE)   action=$ACTION_TSPIN        ;;
          *)
            # For Debugging. cannot be reached.
            echo "invalid tspin action: $action" >> $LOG
            ;;
        esac
        ;;
      $ACTION_MINI_TSPIN)
        case $action in
          $ACTION_SINGLE) action=$ACTION_MINI_TSPIN_SINGLE ;;
          $ACTION_NONE)   action=$ACTION_MINI_TSPIN        ;;
          *)
            # For Debugging. cannot be reached.
            echo "invalid mini-tspin action: $action" >> $LOG
            ;;
        esac
        ;;
    esac
  }
  update_score "$action"

  [ "$action" -eq $ACTION_NONE ]       ||
  [ "$action" -eq $ACTION_MINI_TSPIN ] ||
  [ "$action" -eq $ACTION_TSPIN ]      && return

  beep
  redraw_playfield
  discard_cmds
}

draw_scoreboard() {
  set_bold
  set_fg "$SCORE_COLOR"
  xyprint "$SCORE_X" "$SCORE_Y"       "│SCORE:"
  xyprint "$SCORE_X" $((SCORE_Y + 1)) "│"
  xyprint "$SCORE_X" $((SCORE_Y + 2)) "│"
  xyprint "$SCORE_X" $((SCORE_Y + 3)) "│LINES"
  xyprint "$SCORE_X" $((SCORE_Y + 4)) "│LEVEL"
  xyprint "$SCORE_X" $((SCORE_Y + 5)) "│GOAL"
  reset_colors
}

# Arguments:
#   1 - ACTION name. ex: ACTION_SINGLE
#   2 - (ACTION_HARD_DROP) lines
localvar update_score factor score_to_add lines_to_add i text
_update_score() {
  eval factor=\"\$SCORE_FACTOR_"$1"\"

  score_to_add=0
  lines_to_add=0

  # A Back-to-Back sequence is only broken by a Single, Double, or Triple Line Clear.
  # Locking down a Tetrimino without clearing a line or holding a Tetrimino does not
  # break the Back-to-Back sequence.
  case "$1" in
    "$ACTION_SINGLE")
      score_to_add=$((level * factor)) # Awarded Line Clears
      lines_to_add=$((factor / 100))
      b2b_sequence_continues=false
      actions_to_show='Single'
      ;;
    "$ACTION_DOUBLE")
      score_to_add=$((level * factor)) # Awarded Line Clears
      lines_to_add=$((factor / 100))
      b2b_sequence_continues=false
      actions_to_show='Double'
      ;;
    "$ACTION_TRIPLE")
      score_to_add=$((level * factor)) # Awarded Line Clears
      lines_to_add=$((factor / 100))
      b2b_sequence_continues=false
      actions_to_show='Triple'
      ;;
    "$ACTION_TETRIS")
      score_to_add=$((level * factor)) # Awarded Line Clears
      lines_to_add=$((factor / 100))
      actions_to_show='Tetris'
      ;;
    "$ACTION_MINI_TSPIN")
      score_to_add=$((level * factor)) # Awarded Line Clears
      lines_to_add=$((factor / 100))
      actions_to_show='Mini T-Spin'
      ;;
    "$ACTION_MINI_TSPIN_SINGLE")
      score_to_add=$((level * factor)) # Awarded Line Clears
      lines_to_add=$((factor / 100))
      actions_to_show='Mini T-Spin:Single'
      ;;
    "$ACTION_TSPIN")
      score_to_add=$((level * factor)) # Awarded Line Clears
      lines_to_add=$((factor / 100))
      actions_to_show='T-Spin'
      ;;
    "$ACTION_TSPIN_SINGLE")
      score_to_add=$((level * factor)) # Awarded Line Clears
      lines_to_add=$((factor / 100))
      actions_to_show='T-Spin:Single'
      ;;
    "$ACTION_TSPIN_DOUBLE")
      score_to_add=$((level * factor)) # Awarded Line Clears
      lines_to_add=$((factor / 100))
      actions_to_show='T-Spin:Double'
      ;;
    "$ACTION_TSPIN_TRIPLE")
      score_to_add=$((level * factor)) # Awarded Line Clears
      lines_to_add=$((factor / 100))
      actions_to_show='T-Spin:Triple'
      ;;
    "$ACTION_SOFT_DROP")
      score_to_add=$factor
      ;;
    "$ACTION_HARD_DROP")
      score_to_add=$((factor * $2))
      ;;
  esac

  # Awarded Back-to-Back Bonus
  # start a Back-to-Back sequence after Awarded b2b bonus
  # The first Line Clear in the Back-to-Back sequence does not receive the Back-to-Back
  # Bonus. Only consecutive qualifying Back-to-Back Line Clears after the first in the sequence
  # receive the Back-to-Back Bonus.
  case $1 in
    "$ACTION_TETRIS"|\
    "$ACTION_TSPIN_SINGLE"|"$ACTION_TSPIN_DOUBLE"|"$ACTION_TSPIN_TRIPLE"|\
    "$ACTION_MINI_TSPIN_SINGLE")
      $b2b_sequence_continues && {
        score_to_add=$((score_to_add + score_to_add / 2))
        lines_to_add=$((lines_to_add + lines_to_add / 2))
        actions_to_show="$actions_to_show:B2B"
      }
      b2b_sequence_continues=true;;
  esac

  score=$((score + score_to_add))
  lines_completed=$((lines_completed + lines_to_add))

  [ "$level" -lt "$LEVEL_MAX" ]      &&
  [ "$lines_completed" -ge "$goal" ] && {
    level_up
  }

  set_bold
  set_fg "$SCORE_COLOR"
  xyprint $((SCORE_X + 1)) $((SCORE_Y + 1)) "$score"
  str_lpad text "$lines_completed" 4
  xyprint $((SCORE_X + 8)) $((SCORE_Y + 3)) "$text"
  str_lpad text "$level" 4
  xyprint $((SCORE_X + 8)) $((SCORE_Y + 4)) "$text"
  str_lpad text "$goal" 4
  xyprint $((SCORE_X + 8)) $((SCORE_Y + 5)) "$text"

  IFS_SAVE=$IFS; IFS=:
  set -- $actions_to_show
  IFS=$IFS_SAVE

  # We should clear at least 3 lines (e.g., 'T-Spin; Double; B2B')
  i=7
  for text in "${1:-}" "${2:-}" "${3:-}"; do
    str_rpad text " $text" 12 # max width 12 ' Mini T-Spin'
    xyprint "$SCORE_X" $((SCORE_Y + i)) "$text"
    i=$((i + 1))
  done

  reset_colors
}

update_location() {
  current_piece_x="$1"
  current_piece_y="$2"
  [ $current_piece_y -lt $lowest_line ] && {
    lowest_line=$current_piece_y
    on_reach_lowest
  }
}

on_reach_lowest() {
  # echo 'on_reach_lowest' >> $LOG # For Debugging
  manipulation_counter=0

  # if the tetrimino reached the lowest, it means that tetrimino has space to fall
  # and not lifts up before it lands on.
  # so, we can cancel lockdown timer which is running.
  send_signal "$SIGNAL_CANCEL_LOCKDOWN_TIMER" $timer_pid
}

# this function called when player manipulate tetrimino.
on_manipulation() {
  case $lockdown_rule in
    $LOCKDOWN_RULE_INFINITE)
      send_signal "$SIGNAL_RESTART_LOCKDOWN_TIMER" $timer_pid
      ;;
    $LOCKDOWN_RULE_EXTENDED)
      [ $manipulation_counter -lt $LOCKDOWN_ALLOWED_MANIPULATIONS ] && {
        send_signal "$SIGNAL_RESTART_LOCKDOWN_TIMER" $timer_pid
        manipulation_counter=$((manipulation_counter + 1))
        # echo "mc: $manipulation_counter" >> $LOG # For Debugging. to check counter
      }
      ;;
  esac
}

can_maniqulate() {
  case $lockdown_rule in
    $LOCKDOWN_RULE_EXTENDED)
      [ $manipulation_counter -ge $LOCKDOWN_ALLOWED_MANIPULATIONS ] && {
        return 1 # false
      }
      ;;
  esac
  return 0
}

# moves the piece to the new location if possible
# Arguments:
#   1 - new x coordinate
#   2 - new y coordinate
move_piece() {
  if new_piece_location_ok "$1" "$2"; then            # if new location is ok
    [ "$2" -lt "$current_piece_y" ] && lands_on=false # can move down means not lands on
    clear_current                                     # let's wipe out piece current location
    update_location $1 $2                             # update location
    update_ghost                                      # update ghost with new pose of current piece
    show_current                                      # and draw piece in new location
    return 0                                          # nothing more to do here
  fi                                                  # if we could not move piece to new location

  [ "$2" -eq "$current_piece_y" ] && return 1         # and this was horizontal move

  "$lands_on" || {
    # echo 'Send Lock' >> $LOG # for debugging to check when signal fired.
    send_signal "$SIGNAL_RESTART_LOCKDOWN_TIMER" $timer_pid
  }
  lands_on=true

  return 1
}


# Check a whole Tetrimino is above the Skyline. if yes - Game Over
# Returns:
#   0 - yes
#   1 - no
test_lockout() {
  eval set -- \$piece_"$current_piece"_minos_"$current_piece_rotation"

  while [ $# -gt 0 ]; do
    [ $((current_piece_y - $2)) -lt $PLAYFIELD_H ] && return 1
    shift 2 # shift to next minos coordinates
  done
  return 0
}

lockdown() {
  # if can fall, dont lock down
  new_piece_location_ok "$current_piece_x" $((current_piece_y - 1)) && return

  test_lockout && { # a whole Tetrimino Locks Down above the Skyline - Game Over
    quit; return    # ... Quit
  }

  process_fallen_piece # let's finalize this piece
  get_next             # and start the new one
  already_hold=false   # player can hold the falling tetrimino.
}

# Arguments:
#   1 - rotation direction; 1: clockwise; -1: counter-clockwise
localvar rotate_piece_classic direction old_rotation new_rotation
_rotate_piece_classic() {
  direction="$1"

  old_rotation=$current_piece_rotation                             # preserve current orientation
  new_rotation=$((old_rotation + direction + 4))
  new_rotation=$((new_rotation % 4))                               # calculate new orientation
  current_piece_rotation=$new_rotation                             # set orientation to new
  if new_piece_location_ok $current_piece_x $current_piece_y; then # check if new orientation is ok
    [ $current_piece -eq $T_TETRIMINO ] && {
      what_type_tspin current_tspin $current_piece_x $current_piece_y $new_rotation
    }
    current_piece_rotation=$old_rotation                           # if yes - restore old rotation ...
    clear_current                                                  # ... clear piece image
    current_piece_rotation=$new_rotation                           # ... set new orientation
    update_ghost
    show_current                                                   # ... draw piece with new orientation
    return 0
  fi
  # if new orientation is not ok
  current_piece_rotation=$old_rotation # restore old orientation
  return 1
}

# Arguments:
#   1 - rotation direction; 1: clockwise; -1: counter-clockwise
localvar rotate_piece_super direction old_rotation new_rotation shift_x shift_y new_x new_y point
_rotate_piece_super() {
  direction="$1"

  old_rotation=$current_piece_rotation # preserve current orientation

  new_rotation=$((old_rotation + direction + 4)) #
  new_rotation=$((new_rotation % 4))             # calculate new orientation

  current_piece_rotation=$new_rotation

  # test each rotation point. Each Tetrimino has five possible rotation points.
  eval set -- \$piece_${current_piece}_rshifts_${old_rotation}
  # now parameters setted like below
  # '<POINT1> <POINT2> <POINT3> <POINT4> <POINT5>'
  #   <POINT<NO>>: '<LEFT_SHIFT_X> <LEFT_SHIFT_Y> <RIGHT_SHIFT_X> <RIGHT_SHIFT_Y>'
  [ $direction -eq 1 ] && shift 2 # if rotate clockwise(RIGHT) shift 2 to next xy-coordinates of RIGHT
  while [ $# -gt 0 ]; do
    [ $1 = 'n' ] && {        # if 'not used' appears, skip this point
      [ $# -lt 4 ] && break;
      shift 4; continue;
    }

    shift_x=$1; shift_y=$2
    new_x=$((current_piece_x + shift_x))
    new_y=$((current_piece_y + shift_y))
    if new_piece_location_ok $new_x $new_y; then # check if new orientation is ok
      [ $current_piece -eq $T_TETRIMINO ] && {
        what_type_tspin current_tspin $new_x $new_y $new_rotation
      }
      current_piece_rotation=$old_rotation       # if yes - restore old rotation ...
      clear_current                              # ... clear piece image
      current_piece_rotation=$new_rotation       # ... set new orientation
      update_location $new_x $new_y              # ... set new location
      update_ghost
      show_current                               # ... draw piece with new pose
      return 0                                   # nothing to do more here
    fi

    [ $# -lt 4 ] && break;
    shift 4 # test next rotation point
  done

  # if new orientation is not ok
  current_piece_rotation=$old_rotation # restore old orientation
  return 1
}

move_right() {
  can_maniqulate || return
  move_piece $((current_piece_x + 1)) "$current_piece_y" && {
    # if successfuly move
    current_piece_behaviour=$BEHAVIOUR_RIGHT
    on_manipulation
  }
}

move_left() {
  can_maniqulate || return
  move_piece $((current_piece_x - 1)) "$current_piece_y" && {
    # if successfuly move
    current_piece_behaviour=$BEHAVIOUR_LEFT
    on_manipulation
  }
}

rotate_cw() {
  can_maniqulate || return
  $rotate_piece_func 1 && {
    # if successfuly rotate
    current_piece_behaviour=$BEHAVIOUR_ROTATE
    on_manipulation
  }
}

rotate_ccw() {
  can_maniqulate || return
  $rotate_piece_func -1 && {
    # if successfuly rotate
    current_piece_behaviour=$BEHAVIOUR_ROTATE
    on_manipulation
  }
}

fall() {
  move_piece "$current_piece_x" $((current_piece_y - 1)) && {
    # if successfuly move
    current_piece_behaviour=$BEHAVIOUR_FALL
  }
}

soft_drop() {
  move_piece "$current_piece_x" $((current_piece_y - 1)) && {
    # if successfuly move
    current_piece_behaviour=$BEHAVIOUR_SOFT_DROP
    update_score "$ACTION_SOFT_DROP"
  }
}

# Arguments:
#   1 - x
#   2 - y
# Returns:
#   steps. 0 - no space to fall.
localvar test_hard_drop steps
_test_hard_drop() {
  steps=1
  while new_piece_location_ok $1 $(($2 - steps)); do
    steps=$((steps + 1))
  done
  return $((steps - 1)) # return value must be within 0 ~ 255
}

localvar hard_drop steps
_hard_drop() {
  # move piece all way down
  test_hard_drop $current_piece_x $current_piece_y; steps=$?

  update_score "$ACTION_HARD_DROP" $steps
  move_piece $current_piece_x $((current_piece_y - steps))
  lockdown # A Tetrimino that is Hard Dropped Locks Down immediately

  current_piece_behaviour=$BEHAVIOUR_HARD_DROP
}

hold() {
  hold_tetrimino
}

update_ghost() {
  clear_ghost; show_ghost
}

# Update ghost piece with new location according to current piece.
localvar show_ghost color
_show_ghost() {
  test_hard_drop $current_piece_x $current_piece_y
  ghost_piece_y=$((current_piece_y - $?))
  ghost_piece=$current_piece
  ghost_piece_x=$current_piece_x
  ghost_piece_rotation=$current_piece_rotation

  eval color=\"\$piece_"$current_piece"_color\"

  set_fg "$color"
  draw_playfield_piece $ghost_piece_x $ghost_piece_y $ghost_piece $ghost_piece_rotation "$ghost_cell"

  reset_colors
}

clear_ghost() {
  ${ghost_piece+:} return

  draw_playfield_piece $ghost_piece_x $ghost_piece_y  $ghost_piece $ghost_piece_rotation "$empty_cell"
}

# playfield is 2-dimensional array, data is stored as follows:
# a_{y,x}
#   x - 0, ..., (PLAYFIELD_W-1)
#   y - 0, ..., (PLAYFIELD_H-1), ..., (START_Y-1)
# each array element contains cell color value or -1 if cell is empty
localvar redraw_playfield x y yp field_cell
_redraw_playfield() {
  y=0
  while [ "$y" -lt "$PLAYFIELD_H" ]; do
    yp=$((PLAYFIELD_Y + PLAYFIELD_H - y - 1))
    xyprint $PLAYFIELD_X $yp '' # put the cursor on the front of line
    x=0
    while [ "$x" -lt "$PLAYFIELD_W" ]; do
      eval field_cell="\$playfield_${y}_${x}"

      if [ "$field_cell" -eq -1 ]; then
        puts "$empty_cell"
      else
        set_fg "$field_cell"
        set_bg "$field_cell"
        puts "$filled_cell"
        reset_colors
      fi
      x=$((x + 1))
    done
    y=$((y + 1))
  done
}

# Arguments:
#   1 - x
#   2 - y
#   3 - type
#   4 - rotation
#   5 - cell content
#   6 - mask with playfield
localvar draw_piece posx posy type rotation content x y mask
_draw_piece() {
  # at first, we should save arguments.
  posx="$1"; posy="$2"; type="$3"; rotation="$4"; content="$5"; mask="${6:-false}"

  # set minos coordinates.
  eval set -- \$piece_"$type"_minos_"$rotation"

  # loop through tetrimino minos: 4 minos, each has 2 coordinates
  while [ $# -gt 0 ]; do
    # relative coordinates are retrieved bassed on orientation and added to absolute coordinates
    x=$((posx + $1 * 2)) # the width of cell is 2 characters thick
    y=$((posy + $2))

    "$mask"                                         &&
    [ "$y" -ge "$PLAYFIELD_Y" ]                     &&
    [ "$y" -lt $((PLAYFIELD_Y + PLAYFIELD_H)) ]     &&
    [ "$x" -ge "$PLAYFIELD_X" ]                     &&
    [ "$x" -lt $((PLAYFIELD_X + PLAYFIELD_W * 2)) ] && xyprint $x $y "$content" # draw mino within playfield
    "$mask"                                         || xyprint $x $y "$content"

    shift 2
  done
}

draw_playfield_piece() {
  # factor 2 for x because each cell is 2 characters wide
  draw_piece $((PLAYFIELD_X + $1 * 2)) $((PLAYFIELD_Y + PLAYFIELD_H - 1 - $2)) "$3" "$4" "$5" true
}

# Arguments:
#   1 - string to draw single cell
draw_current() {
  draw_playfield_piece $current_piece_x $current_piece_y $current_piece $current_piece_rotation "$1"
}

localvar show_current color
_show_current() {
  eval color=\"\$piece_"$current_piece"_color\"
  set_fg "$color"
  set_bg "$color"
  draw_current "$filled_cell"
  reset_colors
}

clear_current() {
  draw_current "$empty_cell"
}

# Arguments:
#   1 - visibility ( false - no, true - yes)
localvar draw_next color visible x y content
_draw_next() {
  x="$NEXT_X"; y="$NEXT_Y"; visible="$1"

  set -- $next_queue
  while [ $# -gt 0 ]; do
    content='  '
    "$visible" && {
      eval color=\"\$piece_"$1"_color\"
      set_fg "$color"
      set_bg "$color"
      content="$filled_cell"
    }
    draw_piece "$x" "$y" "$1" "$NORTH" "$content"
    shift
    y=$((y + 3))
  done
  "$visible" && reset_colors
}

show_next() {
  draw_next true
}

clear_next() {
  draw_next false
}

# Arguments:
#   1 - visibility ( false - no, true - yes)
localvar draw_hold visible color
_draw_hold() {
  visible="$1"

  [ -z "$hold_queue" ] && return

  content='  '
  "$visible" && {
    eval color=\"\$piece_"$hold_queue"_color\"
    set_fg "$color"
    set_bg "$color"
    content="$filled_cell"
  }
  draw_piece $((HOLD_X)) $((HOLD_Y)) $hold_queue "$NORTH" "$content"
  "$visible" && reset_colors
}

show_hold() {
  draw_hold true
}

clear_hold() {
  draw_hold false
}

localvar draw_border x1 x2 y1 y2 i x y
_draw_border() {
  set_bold
  set_fg $BORDER_COLOR
  x1=$((PLAYFIELD_X - 1))               # 1 here is because border is 1 characters thick
  x2=$((PLAYFIELD_X + PLAYFIELD_W * 2)) # 2 here is because each cell on play field is 2 characters wide
  y1=$((PLAYFIELD_Y - 1))
  y2=$((PLAYFIELD_Y + PLAYFIELD_H))

  i=0
  while [ "$i" -lt "$PLAYFIELD_H" ]; do
    y=$((i + PLAYFIELD_Y))
    xyprint $x1 $y "│"
    xyprint $x2 $y "│"
    i=$((i + 1))
  done

  i=0
  while [ "$i" -lt "$PLAYFIELD_W" ]; do
    x=$((i * 2 + PLAYFIELD_X)) # 2 here is because each cell on play field is 2 characters width
    xyprint $x $y1 '──'
    xyprint $x $y2 '──'
    i=$((i + 1))
  done

  xyprint $x1 $y1 "┌"; xyprint $x2 $y1 "┐" # draw the corners
  xyprint $x1 $y2 "└"; xyprint $x2 $y2 "┘"

  reset_colors
}

# Arguments:
#   1 - visibility ( false(1) - no, true(0) - yes), if this argument is skipped $help_on is used
localvar draw_help visible x y line
_draw_help() {
  visible=${1:-$help_on}

  x="$HELP_X"; y="$HELP_Y"

  set_bold
  set_fg "$HELP_COLOR"

  IFS_SAVE=$IFS; IFS=$LF
  set -- $HELP
  IFS=$IFS_SAVE

  for line in "$@"; do
    "$visible" || str_repeat line " " ${#line}
    xyprint "$x" "$y" "$line"
    y=$((y + 1))
  done
  reset_colors
}

refresh_screen() {
  clear
  redraw_screen
}

redraw_screen() {
  draw_help                   # should first. draw help on the lowest layer
  show_next
  show_hold
  draw_scoreboard
  update_score "$ACTION_NONE"
  draw_border
  redraw_playfield

  [ ${current_piece:-''} ] && {
    show_ghost
    show_current
  }
}

toggle_help() {
  $help_on && help_on=false || help_on=true
  draw_help
}

toggle_beep() {
  $beep_on && beep_on=false || beep_on=true
  beep
}

toggle_color() {
  $no_color && no_color=false || no_color=true
  redraw_screen
}

quit() {
  running=false                                # let's stop controller ...
  send_signal $SIGNAL_TERM $timer_pid          # let's kill ticker process ...
  send_signal $SIGNAL_TERM $reader_pid         #
  send_signal $SIGNAL_TERM $ticker_pid         #
  xyprint $GAMEOVER_X $GAMEOVER_Y 'Game Over!'

  # put message at bottom of playfield so that game screen will keep its shape.
  xyprint 0 $((PLAYFIELD_Y + PLAYFIELD_H + 1)) '> Quit'
  xyprint 0 $((PLAYFIELD_Y + PLAYFIELD_H + 2)) '> Press any key to continue ...'

  flush_screen
}

localvar init x y i from cmd pid statement
_init() {
  clear
  $debug || echo "$COPYRIGHT"
  echo 'Loading...'

  $debug || {
    i=30
    while [ "$i" -gt 0 ]; do
      printf '\r'; print_loading_spin

      sleep 0.1
      i=$(( i - 1 ))
    done
  }

  # Initialize random generator.
  [ $bag_random -eq 0 ] && {
    # if not set
    bag_random=$(rand)
    [ $bag_random -eq 0 ] && bag_random=$((bag_random + 1))
  }

  # playfield is initialized with -1s (empty cells)
  # x of playfield - 0, ..., (PLAYFIELD_W-1)
  # y of playfield - 0, ..., (PLAYFIELD_H-1), ..., (START_Y), ..., (BUFFER_ZONE_Y)
  # (0, 0) is bottom left
  y=0
  while [ "$y" -le "$BUFFER_ZONE_Y" ]; do
    x=0
    while [ "$x" -lt "$PLAYFIELD_W" ]; do
      eval playfield_"$y"_"$x"=-1
      x=$((x + 1))
    done
    y=$((y + 1))
  done

  # prepare next queue filled with NEXT_MAX tetrimino
  i=0
  while [ "$i" -lt "$NEXT_MAX" ]; do
    feed_next_queue
    i=$((i + 1))
  done

  $debug && echo 'Checking subprocess pid' >> $LOG
  ticker_pid=''; timer_pid=''; reader_pid=''
  while [ -z $ticker_pid ] || [ -z $timer_pid ] || [ -z $reader_pid ]; do
    read statement
    set -- $statement
    [ $# -lt 4 ] && continue
    from=$2; cmd=$3; pid=$4

    [ $cmd -eq $MY_PID ] && {
      case $from in
        $PROCESS_TICKER)
          ticker_pid=$4
          $debug &&  echo "> ticker $ticker_pid ...OK" >> $LOG
          ;;
        $PROCESS_READER)
          reader_pid=$4
          $debug &&  echo "> reader $reader_pid ...OK" >> $LOG
          ;;
        $PROCESS_TIMER)
          timer_pid=$4
          $debug &&  echo "> timer  $timer_pid ...OK" >> $LOG
          ;;
      esac
    }
  done

  # reset to starting level
  reset_level

  # now setup play screen
  clear
  hide_cursor
  redraw_screen

  # show 'READY' for 1 second.
  xyprint $((CENTER_X - 3)) $CENTER_Y 'READY'
  flush_screen
  sleep 1

  # counting down 3 seconds
  i=3
  while [ $i -gt 0 ]; do
    xyprint $((CENTER_X - 1)) $((CENTER_Y + 1)) $i
    flush_screen
    sleep 1
    i=$((i - 1))
  done

  get_next
  redraw_screen
  flush_screen
}

localvar lockdown_timer trigger_counter
_lockdown_timer() {
  # on SIGTERM this process should exit
  trap exit $SIGNAL_TERM
  # on this signal reset the timer. lockdown 0.5~0.6(0.5 is correct) sec after receiving signal
  trap 'trigger_counter=5'  $SIGNAL_RESTART_LOCKDOWN_TIMER
  trap 'trigger_counter=-1' $SIGNAL_CANCEL_LOCKDOWN_TIMER

  game_pid=$1
  get_pid my_pid
  state "$PROCESS_TIMER $MY_PID $my_pid"

  trigger_counter=-1  # -1 - already triggerd; 0 - triggered; greater than 0 - count to trigger
  while exist_process "$game_pid"; do
    [ "$trigger_counter" -eq 0 ] && {
      trigger_counter=-1
      # echo 'Fire Lock' >> $LOG # for debugging to check when signal fired.
      state "$PROCESS_TIMER $LOCKDOWN"
    }
    [ "$trigger_counter" -gt 0 ] && trigger_counter=$((trigger_counter - 1))

    sleep 0.1

    # The following code will cause an error ("Illegal instruction: 4") on macOS(bash 3.2.57).
    #   sleep 0.1 & # wait in background for receiving the signal
    #   wait $!
  done
}

# this function runs in separate process
# it sends FALL commands to controller with appropriate delay
ticker() {
  # on SIGTERM this process should exit
  trap exit $SIGNAL_TERM
  # on this signal fall speed should be increased, this happens during level ups
  trap 'level=$((level + 1))' $SIGNAL_LEVEL_UP
  trap 'level=$starting_level' $SIGNAL_RESET_LEVEL

  game_pid=$1
  get_pid my_pid
  state "$PROCESS_TICKER $MY_PID $my_pid"

  # the game level, which levelup-signal counts up.
  level=$starting_level
  while exist_process "$game_pid"; do
    eval sleep \"\$FALL_SPEED_LEVEL_$level\"

    # The following code will cause an error ("Illegal instruction: 4") on macOS(bash 3.2.57).
    #   eval sleep \"\$FALL_SPEED_LEVEL_$level\" &
    #   wait $!

    state "$PROCESS_TICKER $FALL" # <timestamp> <cmd>

    # echo "$level" >> $LOG # For debuging. check level variable
  done
}

# this function processes keyboard input
localvar reader key a b cmd
_reader() {
  # this process exits on SIGTERM
  trap exit $SIGNAL_TERM

  a='' b=''

  game_pid=$1
  get_pid my_pid
  state "$PROCESS_READER $MY_PID $my_pid"

  # disable terminal local echo (echoback) and canonical input mode
  stty -echo -icanon time 0 min 1

  while exist_process "$game_pid"; do
    # read one key
    key=$(dd ibs=1 count=1 2>/dev/null)
    cmd=''

    # echo "$key" >> $LOG # For debug to check input char.
    # printf '%s' "$key" | od -An -tx1 >> $LOG # For debug to check input char as hex value.

    case "$a$b$key" in
      # 2 escapes
      *"$ESC_CH""$ESC_CH")
        cmd="$QUIT"
        ;;
      # LEFT Arrow, Numpad 4
      *"$ESC_CH"'[D'|*4)
        cmd="$LEFT"
        ;;
      # RIGHT Arrow, Numpad 6
      *"$ESC_CH"'[C'|*6)
        cmd="$RIGHT"
        ;;
      # Space Bar, Numpad 8
      *' '|*8)
        cmd="$HARD_DROP"
        ;;
      # DOWN Arrow, Numpad 2
      *"$ESC_CH"'[B'|*2)
        cmd="$SOFT_DROP"
        ;;
      # UP Arrow, x, Numpad 1 5 9
      *"$ESC_CH"'[A'|*x|*1|*5|*9)
        cmd="$ROTATE_CW"
        ;;
      # z, Numpad 3, 7
      *z|*3|*7)
        cmd="$ROTATE_CCW"
        ;;
      # c, Numpad 0
      *c|*0)
        cmd="$HOLD"
        ;;
      *B)
        cmd="$TOGGLE_BEEP"
        ;;
      *C)
        cmd="$TOGGLE_COLOR"
        ;;
      *R)
        cmd="$REFRESH_SCREEN"
        ;;
      *H)
        cmd="$TOGGLE_HELP"
        ;;
      *Q)
        cmd="$QUIT"
        ;;
    esac
    a=$b   # preserve previous keys
    b=$key
    [ -n "$cmd" ] && state "$PROCESS_READER $cmd" # if not empty string
  done
}

localvar controller cmd statement issued_time from
_controller() {
  # These signals are ignored
  trap '' $SIGNAL_TERM

  # initialization of commands array with appropriate functions
  eval commands_"$QUIT"=quit
  eval commands_"$RIGHT"=move_right
  eval commands_"$LEFT"=move_left
  eval commands_"$ROTATE_CW"=rotate_cw
  eval commands_"$ROTATE_CCW"=rotate_ccw
  eval commands_"$FALL"=fall
  eval commands_"$SOFT_DROP"=soft_drop
  eval commands_"$HARD_DROP"=hard_drop
  eval commands_"$HOLD"=hold
  eval commands_"$REFRESH_SCREEN"=refresh_screen
  eval commands_"$TOGGLE_BEEP"=toggle_beep
  eval commands_"$TOGGLE_COLOR"=toggle_color
  eval commands_"$TOGGLE_HELP"=toggle_help
  eval commands_"$LOCKDOWN"=lockdown

  init
  discard_cmds

  while $running; do # run while this variable is true, it is changed to false in quit function
    # read next command from stdout
    # skip cmds issued before discard_cmds_timepoint
    while read statement; do
      set -- $statement
      [ $# -lt 3 ] && continue   # validate param counts is 3 or more
      issued_time="$1"; from="$2" cmd="$3"
      [ "$issued_time" -gt "$discard_cmds_timepoint" ] && break
    done
    case $cmd in
      "$MY_PID")              ;; # ignore
      *)
        eval eval \"\$commands_"$cmd"\" # run command
        flush_screen
        ;;
    esac
  done
}

game() {
  stty_g=$(stty -g) # let's save terminal state
  trap 'game_cleanup false' $SIGNAL_INT

  # output of ticker, timer and reader is joined and piped into controller
  (
    ticker "$$"         & # runs as separate process
    lockdown_timer "$$" &
    reader "$$"
  ) | (
    controller
  )

  trap "" $SIGNAL_INT
  game_cleanup true
}

game_cleanup() {
  "$1" || {
    xyprint 0 $((PLAYFIELD_Y + PLAYFIELD_H + 1)) '> Abort'
    flush_screen
  }
  echo '' # add new lines
  show_cursor
  stty "$stty_g" # let's restore terminal state
}

# Exit with error message and usage
# Arguments:
#   Error message
die_usage() {
  echo "$PROG: $1" 1>&2
  echo "$USAGE" 1>&2; exit 1
}

main() {
  rotate_piece_func=rotate_piece_super
  starting_level=1
  debug=false
  while [ $# -gt 0 ]; do
    case $1 in
      -d|--debug)
        debug=true
        shift; continue
        ;;
      -l|--level)
        [ $# -le 1 ] && { # if next arg not exists
          die_usage "option '$1' requires an argument"
        }

        { expr "$2" + 1 > /dev/null 2>&1; [ $? -gt 1 ]; } || # if not number
        [ "$2" -lt 1 ]                                    || # ...less than 1
        [ "$2" -gt $LEVEL_MAX ]                           && # ...greater than LEVEL_MAX, then
        {
          die_usage "invalid level '$2'"
        }

        starting_level=$2
        shift 2; continue
        ;;
      --rotation)
        [ $# -le 1 ] && { # if next arg not exists
          die_usage "option '$1' requires an argument"
        }
        case $2 in
          classic) rotate_piece_func=rotate_piece_classic ;;
          super)   rotate_piece_func=rotate_piece_super   ;;
          *)       die_usage "unrecognized rotation mode '$2'" ;;
        esac
        shift 2; continue
        ;;
      --lockdown)
        [ $# -le 1 ] && { # if next arg not exists
          die_usage "option '$1' requires an argument"
        }
        case $2 in
          extended) lockdown_rule=$LOCKDOWN_RULE_EXTENDED ;;
          infinite) lockdown_rule=$LOCKDOWN_RULE_INFINITE ;;
          classic)  lockdown_rule=$LOCKDOWN_RULE_CLASSIC  ;;
          *)        die_usage "unrecognized lockdown rule '$2'" ;;
        esac
        shift 2; continue
        ;;
      --seed)
        [ $# -le 1 ] && { # if next arg not exists
          die_usage "option '$1' requires an argument"
        }

        { expr "$2" + 1 > /dev/null 2>&1; [ $? -gt 1 ]; } || # if not number
        [ "$2" -lt 1 ]                                    || # ...less than 1
        [ "$2" -gt 4294967295 ]                           && # ...greater than LEVEL_MAX, then
        {
          die_usage "invalid seed '$2'"
        }
        bag_random=$2
        shift 2; continue
        ;;
      --no-beep)
        beep_on=false
        shift; continue
        ;;
      --no-color)
        no_color=true
        shift; continue
        ;;
      --hide-help)
        help_on=false
        shift; continue
        ;;
      --help|-h)    echo "$USAGE";   exit ;;
      --version|-V) echo "$VERSION"; exit ;;
      *)            die_usage "unrecognized option '$1'" ;;
    esac
  done

  if $debug; then
    echo "=== Debug mode enabled ===" >> $LOG
    game
  else
    game 2> /dev/null # discard stderr of kill command saying 'User defined signal ...'
  fi
}

main "$@"
